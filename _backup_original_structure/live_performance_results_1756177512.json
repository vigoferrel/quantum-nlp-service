{
  "timestamp": 1756177512.3536525,
  "models_tested": [
    "claude_opus_4_1",
    "gemini_2_5_pro",
    "gpt_5"
  ],
  "results": [
    {
      "model": "Claude Opus 4.1",
      "domain": "programming",
      "query": "Implementa un algoritmo de ordenamiento quicksort optimizado en Python con an√°lisis de complejidad",
      "response": "",
      "score": 0.0,
      "response_time": 120.41198778152466,
      "cost": 0.0,
      "tokens_used": 0,
      "success": false,
      "error": ""
    },
    {
      "model": "Claude Opus 4.1",
      "domain": "programming",
      "query": "Crea una funci√≥n que detecte si un grafo es bipartito usando BFS",
      "response": "Aqu√≠ te muestro una implementaci√≥n completa para detectar si un grafo es bipartito usando BFS:\n\n```python\nfrom collections import deque\n\ndef es_bipartito(grafo):\n    \"\"\"\n    Detecta si un grafo es bipartito usando BFS.\n    \n    Un grafo es bipartito si podemos colorear todos sus nodos con 2 colores\n    de tal forma que ning√∫n par de nodos adyacentes tengan el mismo color.\n    \n    Args:\n        grafo: Diccionario donde las claves son nodos y los valores son listas\n               de nodos adyacentes (lista de adyacencia)\n    \n    Returns:\n        tuple: (es_bipartito: bool, particiones: tuple de dos conjuntos o None)\n    \"\"\"\n    if not grafo:\n        return True, (set(), set())\n    \n    # Diccionario para almacenar el color de cada nodo\n    # 0 y 1 representan los dos colores posibles\n    colores = {}\n    \n    # Conjuntos para almacenar las dos particiones\n    particion_0 = set()\n    particion_1 = set()\n    \n    # Iteramos sobre todos los nodos para manejar grafos desconectados\n    for nodo_inicial in grafo:\n        if nodo_inicial in colores:\n            continue\n            \n        # Iniciamos BFS desde un nodo no visitado\n        cola = deque([nodo_inicial])\n        colores[nodo_inicial] = 0\n        particion_0.add(nodo_inicial)\n        \n        while cola:\n            nodo_actual = cola.popleft()\n            color_actual = colores[nodo_actual]\n            \n            # Revisamos todos los vecinos del nodo actual\n            for vecino in grafo.get(nodo_actual, []):\n                if vecino not in colores:\n                    # Asignamos el color opuesto al vecino\n                    colores[vecino] = 1 - color_actual\n                    cola.append(vecino)\n                    \n                    # Agregamos a la partici√≥n correspondiente\n                    if colores[vecino] == 0:\n                        particion_0.add(vecino)\n                    else:\n                        particion_1.add(vecino)\n                        \n                elif colores[vecino] == color_actual:\n                    # Si el vecino tiene el mismo color, no es bipartito\n                    return False, None\n    \n    return True, (particion_0, particion_1)\n\n\ndef es_bipartito_simple(grafo):\n    \"\"\"\n    Versi√≥n simplificada que solo retorna True/False\n    \"\"\"\n    if not grafo:\n        return True\n    \n    colores = {}\n    \n    for nodo_inicial in grafo:\n        if nodo_inicial in colores:\n            continue\n            \n        cola = deque([nodo_inicial])\n        colores[nodo_inicial] = 0\n        \n        while cola:\n            nodo_actual = cola.popleft()\n            color_actual = colores[nodo_actual]\n            \n            for vecino in grafo.get(nodo_actual, []):\n                if vecino not in colores:\n                    colores[vecino] = 1 - color_actual\n                    cola.append(vecino)\n                elif colores[vecino] == color_actual:\n                    return False\n    \n    return True\n\n\n# Ejemplos de uso\nif __name__ == \"__main__\":\n    # Ejemplo 1: Grafo bipartito\n    grafo_bipartito = {\n        'A': ['B', 'D'],\n        'B': ['A', 'C'],\n        'C': ['B', 'D'],\n        'D': ['A', 'C']\n    }\n    \n    # Ejemplo 2: Grafo NO bipartito (contiene un ciclo impar)\n    grafo_no_bipartito = {\n        'A': ['B', 'C'],\n        'B': ['A', 'C'],\n        'C': ['A', 'B']\n    }\n    \n    # Ejemplo 3: Grafo bipartito desconectado\n    grafo_desconectado = {\n        'A': ['B'],\n        'B': ['A'],\n        'C': ['D'],\n        'D': ['C'],\n        'E': []  # Nodo aislado\n    }\n    \n    # Pruebas\n    print(\"Grafo 1 (cuadrado):\")\n    resultado, particiones = es_bipartito(grafo_bipartito)\n    print(f\"  ¬øEs bipartito? {resultado}\")\n    if particiones:\n        print(f\"  Partici√≥n 1: {particiones[0]}\")\n        print(f\"  Partici√≥n 2: {particiones[1]}\")\n    \n    print(\"\\nGrafo 2 (tri√°ngulo):\")\n    resultado, particiones = es_bipartito(grafo_no_bipartito)\n    print(f\"  ¬øEs bipartito? {resultado}\")\n    \n    print(\"\\nGrafo 3 (desconectado):\")\n    resultado, particiones = es_bipartito(grafo_desconectado)\n    print(f\"  ¬øEs bipartito? {resultado}\")\n    if particiones:\n        print(f\"  Partici√≥n 1: {particiones[0]}\")\n        print(f\"  Partici√≥n 2: {particiones[1]}\")\n```\n\n## Versi√≥n con matriz de adyacencia\n\n```python\nfrom collections import deque\n\ndef es_bipartito_matriz(matriz):\n    \"\"\"\n    Detecta si un grafo representado como matriz de adyacencia es bipartito.\n    \n    Args:\n        matriz: Lista de listas representando la matriz de adyacencia\n                matriz[i][j] = 1 si hay arista entre nodos i y j\n    \n    Returns:\n        bool: True si el grafo es bipartito, False en caso contrario\n    \"\"\"\n    n = len(matriz)\n    if n == 0:\n        return True\n    \n    # -1 significa sin color, 0 y 1 son los dos colores\n    colores = [-1] * n\n    \n    # Procesamos cada componente conectada\n    for inicio in range(n):\n        if colores[inicio] != -1:\n            continue\n            \n        cola = deque([inicio])\n        colores[inicio] = 0\n        \n        while cola:\n            nodo = cola.popleft()\n            \n            for vecino in range(n):\n                # Si hay una arista entre nodo y vecino\n                if matriz[nodo][vecino] == 1:\n                    if colores[vecino] == -1:\n                        # Asignamos color opuesto\n                        colores[vecino] = 1 - colores[nodo]\n                        cola.append(vecino)\n                    elif colores[vecino] == colores[nodo]:\n                        # Mismo color en nodos adyacentes\n                        return False\n    \n    return True\n\n\n# Ejemplo de uso con matriz\nif __name__ == \"__main__\":\n    # Grafo bipartito como matriz\n    matriz_bipartito = [\n        [0, 1, 0, 1],  # A conectado con B y D\n        [1, 0, 1, 0],  # B conectado con A y C\n        [0, 1, 0, 1],  # C conectado con B y D\n        [1, 0, 1, 0]   # D conectado con A y C\n    ]\n    \n    # Grafo no bipartito (tri√°ngulo)\n    matriz_no_bipartito = [\n        [0, 1, 1],  # A conectado con B y C\n        [1, 0, 1],  # B conectado con A y C\n        [1, 1, 0]   # C conectado con A y B\n    ]\n    \n    print(f\"Matriz 1 es bipartito: {es_bipartito_matriz(matriz_bipartito)}\")\n    print(f\"Matriz 2 es bipartito: {es_bipartito_matriz(matriz_no_bipartito)}\")\n```\n\n## Caracter√≠sticas clave del algoritmo:\n\n1. **Complejidad temporal**: O(V + E) donde V es el n√∫mero de v√©rtices y E el n√∫mero de aristas\n2. **Complejidad espacial**: O(V) para almacenar colores y la cola\n\n3. **Principio**: Un grafo es bipartito si y solo si no contiene ciclos de longitud impar\n\n4. **El algoritmo**:\n   - Asigna colores alternados a los nodos usando BFS\n   - Si encuentra dos nodos adyacentes con el mismo color, el grafo no es bipartito\n   - Maneja grafos desconectados procesando cada componente",
      "score": 0.9999999999999999,
      "response_time": 51.19226264953613,
      "cost": 0.16884,
      "tokens_used": 2272,
      "success": true,
      "error": null
    },
    {
      "model": "Claude Opus 4.1",
      "domain": "programming",
      "query": "Desarrolla un sistema de cach√© LRU con complejidad O(1) para todas las operaciones",
      "response": "## Sistema de Cach√© LRU con O(1) en todas las operaciones\n\nTe voy a mostrar una implementaci√≥n completa de un cach√© LRU (Least Recently Used) con complejidad O(1) para todas las operaciones.\n\n### Conceptos Clave\n\nPara lograr O(1) en todas las operaciones, necesitamos:\n1. **HashMap/Dictionary**: Para acceso O(1) a los elementos\n2. **Lista Doblemente Enlazada**: Para mantener el orden de uso y permitir eliminaci√≥n/inserci√≥n O(1)\n\n### Implementaci√≥n en Python\n\n```python\nclass Node:\n    \"\"\"Nodo para la lista doblemente enlazada\"\"\"\n    def __init__(self, key=0, value=0):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n    \"\"\"\n    Cach√© LRU con todas las operaciones en O(1)\n    \"\"\"\n    def __init__(self, capacity: int):\n        \"\"\"\n        Inicializa el cach√© con una capacidad espec√≠fica\n        \n        Args:\n            capacity: N√∫mero m√°ximo de elementos en el cach√©\n        \"\"\"\n        self.capacity = capacity\n        self.cache = {}  # HashMap para acceso O(1)\n        \n        # Nodos dummy para simplificar operaciones en los extremos\n        self.head = Node()  # Dummy head (m√°s reciente)\n        self.tail = Node()  # Dummy tail (menos reciente)\n        \n        # Conectar los nodos dummy\n        self.head.next = self.tail\n        self.tail.prev = self.head\n    \n    def _add_to_head(self, node: Node):\n        \"\"\"\n        A√±ade un nodo justo despu√©s del head (m√°s reciente)\n        Complejidad: O(1)\n        \"\"\"\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n    \n    def _remove_node(self, node: Node):\n        \"\"\"\n        Elimina un nodo de la lista\n        Complejidad: O(1)\n        \"\"\"\n        prev_node = node.prev\n        next_node = node.next\n        prev_node.next = next_node\n        next_node.prev = prev_node\n    \n    def _move_to_head(self, node: Node):\n        \"\"\"\n        Mueve un nodo existente al principio (marca como m√°s reciente)\n        Complejidad: O(1)\n        \"\"\"\n        self._remove_node(node)\n        self._add_to_head(node)\n    \n    def _remove_tail(self):\n        \"\"\"\n        Elimina el nodo menos reciente (justo antes del tail)\n        Complejidad: O(1)\n        \n        Returns:\n            Node eliminado\n        \"\"\"\n        lru_node = self.tail.prev\n        self._remove_node(lru_node)\n        return lru_node\n    \n    def get(self, key: int) -> int:\n        \"\"\"\n        Obtiene el valor de una clave del cach√©\n        Complejidad: O(1)\n        \n        Args:\n            key: Clave a buscar\n            \n        Returns:\n            Valor asociado a la clave, o -1 si no existe\n        \"\"\"\n        if key not in self.cache:\n            return -1\n        \n        # Mover el nodo al principio (marcar como m√°s reciente)\n        node = self.cache[key]\n        self._move_to_head(node)\n        \n        return node.value\n    \n    def put(self, key: int, value: int) -> None:\n        \"\"\"\n        Inserta o actualiza un par clave-valor en el cach√©\n        Complejidad: O(1)\n        \n        Args:\n            key: Clave a insertar/actualizar\n            value: Valor asociado\n        \"\"\"\n        if key in self.cache:\n            # Actualizar valor existente\n            node = self.cache[key]\n            node.value = value\n            self._move_to_head(node)\n        else:\n            # Crear nuevo nodo\n            new_node = Node(key, value)\n            self.cache[key] = new_node\n            self._add_to_head(new_node)\n            \n            # Verificar capacidad\n            if len(self.cache) > self.capacity:\n                # Eliminar el menos reciente\n                lru_node = self._remove_tail()\n                del self.cache[lru_node.key]\n    \n    def delete(self, key: int) -> bool:\n        \"\"\"\n        Elimina una clave del cach√©\n        Complejidad: O(1)\n        \n        Args:\n            key: Clave a eliminar\n            \n        Returns:\n            True si se elimin√≥, False si no exist√≠a\n        \"\"\"\n        if key not in self.cache:\n            return False\n        \n        node = self.cache[key]\n        self._remove_node(node)\n        del self.cache[key]\n        return True\n    \n    def size(self) -> int:\n        \"\"\"\n        Retorna el tama√±o actual del cach√©\n        Complejidad: O(1)\n        \"\"\"\n        return len(self.cache)\n    \n    def clear(self) -> None:\n        \"\"\"\n        Limpia todo el cach√©\n        Complejidad: O(1) amortizado\n        \"\"\"\n        self.cache.clear()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n    \n    def display(self) -> list:\n        \"\"\"\n        Muestra el contenido del cach√© en orden de uso (m√°s reciente primero)\n        Complejidad: O(n)\n        \"\"\"\n        result = []\n        current = self.head.next\n        while current != self.tail:\n            result.append((current.key, current.value))\n            current = current.next\n        return result\n```\n\n### Implementaci√≥n Mejorada con Funcionalidades Adicionales\n\n```python\nfrom typing import Optional, Any, Dict, List, Tuple\nfrom collections import OrderedDict\nimport time\n\nclass AdvancedLRUCache:\n    \"\"\"\n    Cach√© LRU avanzado con estad√≠sticas y TTL opcional\n    \"\"\"\n    def __init__(self, capacity: int, ttl: Optional[float] = None):\n        \"\"\"\n        Args:\n            capacity: Capacidad m√°xima del cach√©\n            ttl: Time-to-live en segundos (opcional)\n        \"\"\"\n        self.capacity = capacity\n        self.ttl = ttl\n        self.cache = OrderedDict()  # Python 3.7+ mantiene orden de inserci√≥n\n        self.timestamps = {} if ttl else None\n        \n        # Estad√≠sticas\n        self.hits = 0\n        self.misses = 0\n        self.evictions = 0\n    \n    def _is_expired(self, key: Any) -> bool:\n        \"\"\"Verifica si una entrada ha expirado\"\"\"\n        if not self.ttl or key not in self.timestamps:\n            return False\n        return time.time() - self.timestamps[key] > self.ttl\n    \n    def get(self, key: Any, default: Any = None) -> Any:\n        \"\"\"\n        Obtiene un valor del cach√©\n        Complejidad: O(1)\n        \"\"\"\n        if key not in self.cache or self._is_expired(key):\n            self.misses += 1\n            if key in self.cache and self._is_expired(key):\n                # Eliminar entrada expirada\n                del self.cache[key]\n                if self.timestamps:\n                    del self.timestamps[key]\n            return default\n        \n        self.hits += 1\n        # Mover al final (m√°s reciente)\n        self.cache.move_to_end(key)\n        return self.cache[key]\n    \n    def put(self, key: Any, value: Any) -> None:\n        \"\"\"\n        Inserta o actualiza un valor en el cach√©\n        Complejidad: O(1)\n        \"\"\"\n        if key in self.cache:\n            # Actualizar existente\n            self.cache.move_to_end(key)\n        else:\n            # Nueva entrada\n            if len(self.cache) >= self.capacity:\n                # Eliminar el menos reciente\n                oldest = next(iter(self.cache))\n                del self.cache[oldest]\n                if self.timestamps:\n                    del self.timestamps[oldest]\n                self.evictions += 1\n        \n        self.cache[key] = value\n        if self.timestamps is not None:\n            self.timestamps[key] = time.time()\n    \n    def delete(self, key: Any) -> bool:\n        \"\"\"\n        Elimina una entrada del cach√©\n        Complejidad: O(1)\n        \"\"\"\n        if key in self.cache:\n            del self.cache[key]\n            if self.timestamps:\n                del self.timestamps[key]\n            return True\n        return False\n    \n    def clear(self) -> None:\n        \"\"\"Limpia todo el cach√©\"\"\"\n        self.cache.clear()\n        if self.timestamps:\n            self.timestamps.clear()\n    \n    def get_stats(self) -> Dict[str, Any]:\n        \"\"\"Retorna estad√≠sticas del cach√©\"\"\"\n        total_requests = self.hits + self.misses\n        hit_rate = self.hits / total_requests if total_requests > 0 else 0\n        \n        return {\n            'size': len(self.cache),\n            'capacity': self.capacity,\n            'hits': self.hits,\n            'misses': self.misses,\n            'evictions': self.evictions,\n            'hit_rate': f\"{hit_rate:.2%}\",\n            'total_requests': total_requests\n        }\n    \n    def get_items(self) -> List[Tuple[Any, Any]]:\n        \"\"\"Retorna todos los items en orden LRU\"\"\"\n        return list(self.cache.items())\n```\n\n### Ejemplo de Uso\n\n```python\ndef demo_lru_cache():\n    \"\"\"Demostraci√≥n del cach√© LRU\"\"\"\n    \n    # Crear cach√© con capacidad 3\n    cache = LRUCache(3)\n    \n    print(\"=== Demostraci√≥n de Cach√© LRU ===\\n\")\n    \n    # Insertar elementos\n    cache.put(1, \"A\")\n    cache.put(2, \"B\")\n    cache.put(3, \"C\")\n    print(f\"Despu√©s de insertar (1,A), (2,B), (3,C):\")\n    print(f\"Estado: {cache.display()}\\n\")\n    \n    # Acceder a un elemento\n    value = cache.get(1)\n    print(f\"get(1) = {value}\")\n    print(f\"Estado: {cache.display()} (1 movido al frente)\\n\")\n    \n    # Insertar nuevo elemento (causa evicci√≥n)\n    cache.put(4, \"D\")\n    print(f\"Despu√©s de put(4,D) - se elimina el menos usado (2):\")\n    print(f\"Estado: {cache.display()}\\n\")\n    \n    # Actualizar elemento existente\n    cache.put(3, \"C_updated\")\n    print(f\"Despu√©s de actualizar (3,C_updated):\")\n    print(f\"Estado: {cache.display()}\\n\")\n    \n    # Eliminar elemento\n    cache.delete(1)\n    print(f\"Despu√©s de delete(1):\")\n    print(f\"Estado: {cache.display()}\\n\")\n    \n    print(\"=== Demostraci√≥n con TTL ===\\n\")\n    \n    # Cach√© con TTL de 2 segundos\n    ttl_cache = AdvancedLRUCache(capacity=3, ttl=2)\n    \n    ttl_cache.put(\"key1\", \"value1\")\n    print(f\"put('key1', 'value1')\")\n    print(f\"get('key1') = {ttl_cache.get('key1')}\")\n    \n    print(\"Esperando 3 segundos...\")\n    time.sleep(3)\n    \n    print(f\"get('key1') despu√©s de expirar = {ttl_cache.get('key1', 'NOT_FOUND')}\")\n    \n    print(\"\\n=== Estad√≠sticas ===\")\n    \n    # Cach√© con estad√≠sticas\n    stats_cache = AdvancedLRUCache(capacity=2)\n    \n    # Simular uso\n    stats_cache.put(\"a\", 1)\n    stats_cache.put(\"b\", 2)\n    stats_cache.get(\"a\")  # hit\n    stats_cache.get(\"c\")  # miss\n    stats_cache.put(\"c\", 3)  # eviction\n    stats_cache.get(\"b\")  # miss (fue eliminado)\n    stats_cache.get(\"a\")  # hit\n    \n    print(stats_cache.get_stats())\n\nif __name__ == \"__main__\":\n    demo_lru_cache()\n```\n\n### Tests Unitarios\n\n```python\nimport unittest\n\nclass TestLRUCache(unittest.TestCase):\n    def test_basic_operations(self):\n        cache = LRUCache(2)\n        \n        cache.put(1, 1)\n        cache.put(2, 2)\n        self.assertEqual(cache.get(1), 1)\n        \n        cache.put(3, 3)  # Elimina key 2\n        self.assertEqual(cache.get(2), -1)\n        \n        cache.put(4, 4)  # Elimina key 1\n        self.assertEqual(cache.get(1), -1)\n        self.assertEqual(cache.get(3), 3)\n        self.assertEqual(cache.get(4), 4)\n    \n    def test_update_existing(self):\n        cache = LRUCache(2)\n        \n        cache.put(1, 1)\n        cache.put(2, 2)\n        cache.put(1, 10)  # Actualizar\n        \n        self.assertEqual(cache.get(1), 10)\n        self.assertEqual(cache.size(), 2)\n    \n    def test_delete(self):\n        cache = LRUCache(3)\n        \n        cache.put(1, 1)\n        cache.put(2, 2)\n        \n        self.assertTrue(cache.delete(1))\n        self.assertFalse(cache.delete(1))  # Ya no existe\n        self.assertEqual(cache.get(1), -1)\n\nif __name__ == \"__main__\":\n    unittest.main()\n```\n\n### An√°lisis de Complejidad\n\n| Operaci√≥n | Complejidad Temporal | Complejidad Espacial |\n|-----------|---------------------|---------------------|\n| get()     | O(1)                | O(1)                |\n| put()     | O(1)                | O(1)                |\n| delete()  | O(1)                | O(1)                |\n| size()    | O(1)                | O(1)                |\n| clear()   | O(1)*               | O(1)                |\n\n*O(1) amortizado\n\n**Espacio total**: O(n) donde n es la capacidad del cach√©\n\nEsta implementaci√≥n es eficiente y pr√°ctica para sistemas que requieren cach√© de alto rendimiento con pol√≠tica de evicci√≥n LRU.",
      "score": 0.9,
      "response_time": 88.29634094238281,
      "cost": 0.29094,
      "tokens_used": 3904,
      "success": true,
      "error": null
    },
    {
      "model": "Claude Opus 4.1",
      "domain": "reasoning",
      "query": "Analiza la complejidad computacional del problema del viajante y prop√≥n una soluci√≥n aproximada",
      "response": "",
      "score": 0.0,
      "response_time": 120.39443922042847,
      "cost": 0.0,
      "tokens_used": 0,
      "success": false,
      "error": ""
    },
    {
      "model": "Claude Opus 4.1",
      "domain": "reasoning",
      "query": "Explica paso a paso c√≥mo resolver el problema de las 8 reinas usando backtracking",
      "response": "## Soluci√≥n del Problema de las 8 Reinas con Backtracking\n\n### üìã **¬øQu√© es el problema de las 8 reinas?**\nColocar 8 reinas en un tablero de ajedrez 8√ó8 de manera que ninguna reina pueda atacar a otra (no pueden estar en la misma fila, columna o diagonal).\n\n### üéØ **Estrategia con Backtracking**\n\n## **Paso 1: Representaci√≥n del tablero**\n\n```python\n# Tablero como lista donde el √≠ndice = fila, valor = columna\n# tablero[i] = j significa que hay una reina en fila i, columna j\ntablero = [-1] * 8  # Inicialmente vac√≠o\n```\n\n## **Paso 2: Funci√≥n para verificar si una posici√≥n es segura**\n\n```python\ndef es_seguro(tablero, fila, columna):\n    \"\"\"\n    Verifica si podemos colocar una reina en (fila, columna)\n    \"\"\"\n    # Verificar todas las filas anteriores\n    for i in range(fila):\n        # Verificar columna\n        if tablero[i] == columna:\n            return False\n        \n        # Verificar diagonal principal (‚Üò)\n        if tablero[i] - i == columna - fila:\n            return False\n        \n        # Verificar diagonal secundaria (‚Üô)\n        if tablero[i] + i == columna + fila:\n            return False\n    \n    return True\n```\n\n## **Paso 3: Algoritmo de Backtracking**\n\n```python\ndef resolver_8_reinas(tablero, fila=0):\n    \"\"\"\n    Resuelve el problema usando backtracking\n    \"\"\"\n    # Caso base: todas las reinas colocadas\n    if fila == 8:\n        return True\n    \n    # Intentar colocar reina en cada columna de la fila actual\n    for columna in range(8):\n        if es_seguro(tablero, fila, columna):\n            # Colocar reina\n            tablero[fila] = columna\n            \n            # Recursi√≥n para la siguiente fila\n            if resolver_8_reinas(tablero, fila + 1):\n                return True\n            \n            # Backtrack: quitar la reina si no funcion√≥\n            tablero[fila] = -1\n    \n    # No se encontr√≥ soluci√≥n\n    return False\n```\n\n## **Paso 4: Implementaci√≥n completa con visualizaci√≥n**\n\n```python\ndef imprimir_tablero(tablero):\n    \"\"\"\n    Imprime el tablero de forma visual\n    \"\"\"\n    for fila in range(8):\n        for columna in range(8):\n            if tablero[fila] == columna:\n                print(\"‚ôõ\", end=\" \")\n            else:\n                print(\"¬∑\", end=\" \")\n        print()\n    print()\n\ndef encontrar_todas_soluciones():\n    \"\"\"\n    Encuentra todas las 92 soluciones posibles\n    \"\"\"\n    soluciones = []\n    \n    def backtrack(tablero, fila):\n        if fila == 8:\n            soluciones.append(tablero[:])  # Guardar copia\n            return\n        \n        for columna in range(8):\n            if es_seguro(tablero, fila, columna):\n                tablero[fila] = columna\n                backtrack(tablero, fila + 1)\n                tablero[fila] = -1  # Backtrack\n    \n    tablero = [-1] * 8\n    backtrack(tablero, 0)\n    return soluciones\n\n# Ejecutar\ntablero = [-1] * 8\nif resolver_8_reinas(tablero):\n    print(\"Soluci√≥n encontrada:\")\n    imprimir_tablero(tablero)\n```\n\n## **üìä Proceso paso a paso del algoritmo:**\n\n### **Iteraci√≥n ejemplo:**\n\n```\nFila 0: Prueba columna 0 ‚úì (primera fila, siempre segura)\nFila 1: \n  - Columna 0 ‚úó (misma columna)\n  - Columna 1 ‚úó (diagonal)\n  - Columna 2 ‚úì (segura, continuar)\nFila 2:\n  - Columna 0 ‚úó (columna ocupada)\n  - Columna 1 ‚úó (diagonal)\n  - Columna 2 ‚úó (columna ocupada)\n  - Columna 3 ‚úó (diagonal)\n  - Columna 4 ‚úì (segura, continuar)\n...\nSi no hay soluci√≥n ‚Üí BACKTRACK a fila anterior\n```\n\n## **üîë Conceptos clave del Backtracking:**\n\n1. **Exploraci√≥n sistem√°tica**: Prueba todas las opciones posibles\n2. **Poda**: Descarta caminos que no llevan a soluci√≥n\n3. **Retroceso**: Cuando falla, vuelve al estado anterior\n4. **Recursi√≥n**: Divide el problema en subproblemas m√°s peque√±os\n\n## **‚ö° Optimizaciones posibles:**\n\n```python\nclass OptimizedQueens:\n    def __init__(self):\n        self.columnas = set()\n        self.diag_principal = set()\n        self.diag_secundaria = set()\n        self.soluciones = []\n    \n    def resolver(self, fila=0, tablero=[]):\n        if fila == 8:\n            self.soluciones.append(tablero[:])\n            return\n        \n        for col in range(8):\n            if (col not in self.columnas and\n                fila - col not in self.diag_principal and\n                fila + col not in self.diag_secundaria):\n                \n                # Colocar reina\n                self.columnas.add(col)\n                self.diag_principal.add(fila - col)\n                self.diag_secundaria.add(fila + col)\n                tablero.append(col)\n                \n                # Recursi√≥n\n                self.resolver(fila + 1, tablero)\n                \n                # Backtrack\n                self.columnas.remove(col)\n                self.diag_principal.remove(fila - col)\n                self.diag_secundaria.remove(fila + col)\n                tablero.pop()\n```\n\n### **Complejidad:**\n- **Tiempo**: O(N!) en el peor caso\n- **Espacio**: O(N) para la recursi√≥n\n\nEl backtracking es perfecto para este problema porque:\n- Construye la soluci√≥n incrementalmente\n- Detecta conflictos temprano\n- Retrocede eficientemente cuando no hay soluci√≥n",
      "score": 0.95,
      "response_time": 44.13099431991577,
      "cost": 0.12825,
      "tokens_used": 1734,
      "success": true,
      "error": null
    },
    {
      "model": "Claude Opus 4.1",
      "domain": "reasoning",
      "query": "Demuestra por qu√© el algoritmo de Dijkstra no funciona con pesos negativos",
      "response": "## Demostraci√≥n de por qu√© Dijkstra falla con pesos negativos\n\n### 1. **Principio Fundamental de Dijkstra**\n\nEl algoritmo de Dijkstra se basa en el **principio de optimalidad**: una vez que un nodo es marcado como \"visitado\" con su distancia m√≠nima, esa distancia es definitiva y no se vuelve a actualizar.\n\n### 2. **Contraejemplo Simple**\n\nConsideremos este grafo:\n\n```\n    A ---1---> B\n    |          |\n    3          -5\n    |          ‚Üì\n    ‚îî--------> C\n```\n\n**Pesos de las aristas:**\n- A ‚Üí B: 1\n- A ‚Üí C: 3  \n- B ‚Üí C: -5\n\n### 3. **Ejecuci√≥n del Algoritmo**\n\n**Paso 1:** Inicializaci√≥n\n- dist[A] = 0 (origen)\n- dist[B] = ‚àû\n- dist[C] = ‚àû\n- Cola de prioridad: {A(0)}\n\n**Paso 2:** Procesar A\n- Extraemos A con distancia 0\n- Actualizamos vecinos:\n  - dist[B] = min(‚àû, 0+1) = 1\n  - dist[C] = min(‚àû, 0+3) = 3\n- Cola: {B(1), C(3)}\n- A se marca como visitado ‚úì\n\n**Paso 3:** Procesar B\n- Extraemos B con distancia 1\n- Actualizamos vecinos:\n  - dist[C] = min(3, 1+(-5)) = -4 ‚ùå\n- **PROBLEMA:** C ya podr√≠a haber sido procesado\n- B se marca como visitado ‚úì\n\n**Paso 4:** Procesar C\n- Si C fue procesado antes con distancia 3, ya est√° marcado como visitado\n- **No se actualizar√≠a** a la distancia correcta de -4\n\n### 4. **El Problema Fundamental**\n\n```python\n# Pseudoc√≥digo del problema\ndef dijkstra_incorrecto(grafo, origen):\n    visitados = set()\n    distancias = {v: infinito for v in grafo}\n    distancias[origen] = 0\n    \n    while hay_nodos_sin_visitar:\n        u = nodo_con_menor_distancia()\n        visitados.add(u)  # ‚Üê Una vez visitado, no se reconsidera\n        \n        for vecino in grafo[u]:\n            if vecino not in visitados:\n                # Solo actualiza si NO est√° visitado\n                distancias[vecino] = min(distancias[vecino], \n                                       distancias[u] + peso(u, vecino))\n```\n\n### 5. **Por Qu√© Falla: An√°lisis Formal**\n\n**Invariante de Dijkstra:** \n> \"Cuando un nodo v es extra√≠do de la cola de prioridad, dist[v] es la distancia m√≠nima desde el origen\"\n\n**Esta invariante se rompe con pesos negativos porque:**\n\n1. Sea `v` un nodo extra√≠do con distancia `d`\n2. Existe un camino alternativo: origen ‚Üí ... ‚Üí u ‚Üí v\n3. Si la arista (u,v) tiene peso negativo suficientemente grande\n4. El camino alternativo podr√≠a ser m√°s corto que `d`\n5. Pero `v` ya fue procesado y no se reconsiderar√°\n\n### 6. **Ejemplo Completo con Traza**\n\n```\nGrafo:\n    S ---2---> A ---3---> T\n    |                     ‚Üë\n    ‚îî----5----‚Üí B ---(-4)-‚îò\n\nCamino √≥ptimo real: S ‚Üí A ‚Üí B ‚Üí T (costo: 2 + 3 + (-4) = 1)\nDijkstra encuentra: S ‚Üí B ‚Üí T (costo: 5 + (-4) = 1) ‚úì (casualidad)\n                 o  S ‚Üí A ‚Üí T (costo: 2 + 3 = 5) ‚ùå (si T se procesa primero)\n```\n\n### 7. **Conclusi√≥n**\n\nEl algoritmo de Dijkstra **no garantiza** encontrar el camino m√°s corto con pesos negativos porque:\n\n1. **Asume monotonicidad:** Las distancias solo pueden crecer al alejarse del origen\n2. **Decisiones irreversibles:** Una vez visitado, un nodo no se reconsidera\n3. **Orden de procesamiento incorrecto:** Puede procesar nodos en orden sub√≥ptimo\n\n### 8. **Alternativas para Grafos con Pesos Negativos**\n\n- **Bellman-Ford:** O(VE) - Funciona con pesos negativos\n- **Floyd-Warshall:** O(V¬≥) - Para todos los pares de caminos m√°s cortos\n- **Johnson:** O(V¬≤log V + VE) - Combina Dijkstra y Bellman-Ford\n\n```python\n# Bellman-Ford maneja pesos negativos correctamente\ndef bellman_ford(grafo, origen):\n    dist = {v: float('inf') for v in grafo}\n    dist[origen] = 0\n    \n    # Relaja todas las aristas V-1 veces\n    for _ in range(len(grafo) - 1):\n        for u in grafo:\n            for v, peso in grafo[u]:\n                dist[v] = min(dist[v], dist[u] + peso)\n    \n    return dist\n```",
      "score": 1.0,
      "response_time": 45.43346309661865,
      "cost": 0.1047,
      "tokens_used": 1420,
      "success": true,
      "error": null
    },
    {
      "model": "Claude Opus 4.1",
      "domain": "mathematics",
      "query": "Demuestra la f√≥rmula de Euler e^(iœÄ) + 1 = 0 usando series de Taylor",
      "response": "## Demostraci√≥n de la Identidad de Euler usando Series de Taylor\n\n### Paso 1: Series de Taylor necesarias\n\nPrimero, recordemos las series de Taylor para las funciones exponencial, seno y coseno:\n\n$$e^x = \\sum_{n=0}^{\\infty} \\frac{x^n}{n!} = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\frac{x^4}{4!} + ...$$\n\n$$\\cos(x) = \\sum_{n=0}^{\\infty} \\frac{(-1)^n x^{2n}}{(2n)!} = 1 - \\frac{x^2}{2!} + \\frac{x^4}{4!} - \\frac{x^6}{6!} + ...$$\n\n$$\\sin(x) = \\sum_{n=0}^{\\infty} \\frac{(-1)^n x^{2n+1}}{(2n+1)!} = x - \\frac{x^3}{3!} + \\frac{x^5}{5!} - \\frac{x^7}{7!} + ...$$\n\n### Paso 2: Evaluaci√≥n de $e^{ix}$\n\nSustituyamos $x = i\\theta$ en la serie de $e^x$:\n\n$$e^{i\\theta} = \\sum_{n=0}^{\\infty} \\frac{(i\\theta)^n}{n!} = 1 + i\\theta + \\frac{(i\\theta)^2}{2!} + \\frac{(i\\theta)^3}{3!} + \\frac{(i\\theta)^4}{4!} + ...$$\n\n### Paso 3: C√°lculo de las potencias de $i$\n\nRecordemos que:\n- $i^0 = 1$\n- $i^1 = i$\n- $i^2 = -1$\n- $i^3 = -i$\n- $i^4 = 1$\n- $i^5 = i$\n- ...\n\nEl patr√≥n se repite cada 4 potencias.\n\n### Paso 4: Sustituci√≥n en la serie\n\n$$e^{i\\theta} = 1 + i\\theta + \\frac{i^2\\theta^2}{2!} + \\frac{i^3\\theta^3}{3!} + \\frac{i^4\\theta^4}{4!} + \\frac{i^5\\theta^5}{5!} + ...$$\n\n$$e^{i\\theta} = 1 + i\\theta - \\frac{\\theta^2}{2!} - \\frac{i\\theta^3}{3!} + \\frac{\\theta^4}{4!} + \\frac{i\\theta^5}{5!} - ...$$\n\n### Paso 5: Separaci√≥n en partes real e imaginaria\n\nAgrupando t√©rminos reales e imaginarios:\n\n**Parte real:**\n$$\\Re(e^{i\\theta}) = 1 - \\frac{\\theta^2}{2!} + \\frac{\\theta^4}{4!} - \\frac{\\theta^6}{6!} + ... = \\cos(\\theta)$$\n\n**Parte imaginaria:**\n$$\\Im(e^{i\\theta}) = \\theta - \\frac{\\theta^3}{3!} + \\frac{\\theta^5}{5!} - \\frac{\\theta^7}{7!} + ... = \\sin(\\theta)$$\n\n### Paso 6: F√≥rmula de Euler\n\nPor lo tanto, hemos demostrado que:\n\n$$\\boxed{e^{i\\theta} = \\cos(\\theta) + i\\sin(\\theta)}$$\n\n### Paso 7: Caso particular $\\theta = \\pi$\n\nSustituyendo $\\theta = \\pi$:\n\n$$e^{i\\pi} = \\cos(\\pi) + i\\sin(\\pi)$$\n\nSabemos que:\n- $\\cos(\\pi) = -1$\n- $\\sin(\\pi) = 0$\n\nPor lo tanto:\n$$e^{i\\pi} = -1 + i(0) = -1$$\n\n### Conclusi√≥n\n\n$$\\boxed{e^{i\\pi} + 1 = 0}$$\n\nEsta es la **Identidad de Euler**, considerada una de las ecuaciones m√°s bellas de las matem√°ticas, ya que relaciona cinco de las constantes matem√°ticas m√°s importantes: $e$, $i$, $\\pi$, $1$ y $0$.",
      "score": 0.6,
      "response_time": 26.44960117340088,
      "cost": 0.085695,
      "tokens_used": 1173,
      "success": true,
      "error": null
    },
    {
      "model": "Claude Opus 4.1",
      "domain": "mathematics",
      "query": "Calcula la derivada de la funci√≥n f(x) = ln(sin(x^2)) usando la regla de la cadena",
      "response": "Voy a calcular la derivada de f(x) = ln(sin(x¬≤)) usando la regla de la cadena paso a paso.\n\n## Identificaci√≥n de las funciones compuestas\n\nLa funci√≥n f(x) = ln(sin(x¬≤)) es una composici√≥n de tres funciones:\n- Funci√≥n externa: ln(u)\n- Funci√≥n intermedia: sin(v)  \n- Funci√≥n interna: x¬≤\n\n## Aplicaci√≥n de la regla de la cadena\n\nLa regla de la cadena establece que:\n**f'(x) = [derivada de ln(u)] ¬∑ [derivada de sin(v)] ¬∑ [derivada de x¬≤]**\n\n### Paso 1: Derivada de la funci√≥n externa\nSi u = sin(x¬≤), entonces:\n- d/du[ln(u)] = 1/u = 1/sin(x¬≤)\n\n### Paso 2: Derivada de la funci√≥n intermedia\nSi v = x¬≤, entonces:\n- d/dv[sin(v)] = cos(v) = cos(x¬≤)\n\n### Paso 3: Derivada de la funci√≥n interna\n- d/dx[x¬≤] = 2x\n\n### Paso 4: Multiplicaci√≥n de las derivadas\nAplicando la regla de la cadena:\n\nf'(x) = 1/sin(x¬≤) ¬∑ cos(x¬≤) ¬∑ 2x\n\n## Simplificaci√≥n\n\nf'(x) = (2x ¬∑ cos(x¬≤))/sin(x¬≤)\n\nEsto tambi√©n se puede escribir como:\n\n**f'(x) = 2x ¬∑ cot(x¬≤)**\n\ndonde cot(x¬≤) = cos(x¬≤)/sin(x¬≤) es la cotangente.\n\n## Respuesta final\n\n**f'(x) = 2x ¬∑ cot(x¬≤)** \n\no equivalentemente:\n\n**f'(x) = (2x ¬∑ cos(x¬≤))/sin(x¬≤)**",
      "score": 0.45,
      "response_time": 16.813982725143433,
      "cost": 0.035879999999999995,
      "tokens_used": 508,
      "success": true,
      "error": null
    },
    {
      "model": "Claude Opus 4.1",
      "domain": "mathematics",
      "query": "Resuelve la ecuaci√≥n diferencial dy/dx + 2y = e^(-x) con condici√≥n inicial y(0) = 1",
      "response": "Resolver√© esta ecuaci√≥n diferencial lineal de primer orden usando el m√©todo del factor integrante.\n\n## Paso 1: Identificar la forma est√°ndar\nLa ecuaci√≥n est√° en la forma est√°ndar:\n$$\\frac{dy}{dx} + P(x)y = Q(x)$$\n\ndonde $P(x) = 2$ y $Q(x) = e^{-x}$\n\n## Paso 2: Calcular el factor integrante\nEl factor integrante es:\n$$\\mu(x) = e^{\\int P(x)dx} = e^{\\int 2dx} = e^{2x}$$\n\n## Paso 3: Multiplicar la ecuaci√≥n por el factor integrante\nMultiplicando ambos lados por $e^{2x}$:\n$$e^{2x}\\frac{dy}{dx} + 2e^{2x}y = e^{2x} \\cdot e^{-x}$$\n$$e^{2x}\\frac{dy}{dx} + 2e^{2x}y = e^{x}$$\n\n## Paso 4: Reconocer que el lado izquierdo es una derivada\nEl lado izquierdo es la derivada de $ye^{2x}$:\n$$\\frac{d}{dx}(ye^{2x}) = e^{x}$$\n\n## Paso 5: Integrar ambos lados\n$$\\int \\frac{d}{dx}(ye^{2x})dx = \\int e^{x}dx$$\n$$ye^{2x} = e^{x} + C$$\n\n## Paso 6: Despejar y\n$$y = \\frac{e^{x} + C}{e^{2x}} = e^{-x} + Ce^{-2x}$$\n\n## Paso 7: Aplicar la condici√≥n inicial\nUsando $y(0) = 1$:\n$$1 = e^{0} + Ce^{0}$$\n$$1 = 1 + C$$\n$$C = 0$$\n\n## Soluci√≥n final\n$$\\boxed{y = e^{-x}}$$\n\n## Verificaci√≥n\nPodemos verificar que nuestra soluci√≥n es correcta:\n- $\\frac{dy}{dx} = -e^{-x}$\n- Sustituyendo en la ecuaci√≥n original: $-e^{-x} + 2e^{-x} = e^{-x}$ ‚úì\n- Condici√≥n inicial: $y(0) = e^{0} = 1$ ‚úì",
      "score": 0.45,
      "response_time": 19.32352304458618,
      "cost": 0.0483,
      "tokens_used": 676,
      "success": true,
      "error": null
    },
    {
      "model": "Gemini 2.5 Pro",
      "domain": "programming",
      "query": "Implementa un algoritmo de ordenamiento quicksort optimizado en Python con an√°lisis de complejidad",
      "response": "¬°Claro! A continuaci√≥n, te presento una implementaci√≥n detallada de un algoritmo Quicksort optimizado en Python, junto con un an√°lisis exhaustivo de su complejidad y las mejoras aplicadas.\n\n### ¬øQu√© es Quicksort?\n\nQuicksort es un algoritmo de ordenamiento muy eficiente que sigue el paradigma de \"divide y vencer√°s\". Su funcionamiento b√°sico es:\n\n1.  **Elegir un pivote:** Se selecciona un elemento del arreglo como pivote.\n2.  **Partici√≥n:** Se reordenan los elementos del arreglo de tal manera que todos los elementos menores que el pivote queden a su izquierda y todos los mayores queden a su derecha. El pivote queda en su posici√≥n final.\n3.  **Recursi√≥n:** Se aplica el mismo proceso de forma recursiva a los sub-arreglos de elementos menores y mayores.\n\n### Problemas del Quicksort B√°sico y Optimizaciones\n\nEl Quicksort \"ingenuo\" puede tener un rendimiento muy pobre (O(n¬≤)) en ciertos casos, como cuando el arreglo ya est√° ordenado o casi ordenado y se elige siempre el primer o √∫ltimo elemento como pivote. Las optimizaciones que implementaremos abordan estos problemas:\n\n1.  **Selecci√≥n de Pivote \"Mediana de Tres\"**: Para evitar el peor caso en arreglos ordenados o inversos, en lugar de elegir el primer o √∫ltimo elemento, se elige la mediana entre el primer, el del medio y el √∫ltimo elemento del sub-arreglo. Esto hace mucho m√°s probable que el pivote sea un buen separador.\n\n2.  **Cambio a Insertion Sort para Sub-arreglos Peque√±os**: Quicksort tiene una sobrecarga por la recursi√≥n. Para arreglos muy peque√±os, un algoritmo m√°s simple como Insertion Sort es en realidad m√°s r√°pido. Por lo tanto, cuando un sub-arreglo a ordenar es menor que un umbral (ej. 10 elementos), cambiamos a Insertion Sort.\n\n3.  **Eliminaci√≥n de Recursi√≥n de Cola (Simulaci√≥n Iterativa)**: Python no optimiza la recursi√≥n de cola, lo que puede llevar a un error de `RecursionError` (desbordamiento de la pila de llamadas) con arreglos muy grandes. Para evitarlo, podemos implementar Quicksort de forma iterativa usando una pila expl√≠cita (una lista en Python). Adem√°s, para optimizar el uso de memoria, siempre procesamos primero el sub-arreglo m√°s peque√±o y apilamos el m√°s grande. Esto garantiza que la profundidad de la pila no exceda O(log n).\n\n---\n\n### Implementaci√≥n del Algoritmo Quicksort Optimizado\n\nAqu√≠ est√° el c√≥digo completo en Python que incorpora las tres optimizaciones mencionadas.\n\n```python\nimport random\n\n# Umbral para cambiar a Insertion Sort. Un valor entre 5 y 15 es t√≠pico.\nINSERTION_SORT_CUTOFF = 10\n\ndef insertion_sort(arr, low, high):\n    \"\"\"\n    Ordena una porci√≥n del arreglo (de 'low' a 'high') usando Insertion Sort.\n    Es eficiente para arreglos peque√±os.\n    \"\"\"\n    for i in range(low + 1, high + 1):\n        key = arr[i]\n        j = i - 1\n        while j >= low and arr[j] > key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n\ndef partition(arr, low, high):\n    \"\"\"\n    Funci√≥n de partici√≥n que utiliza la estrategia \"Mediana de Tres\" para elegir el pivote.\n    \"\"\"\n    # 1. Selecci√≥n de pivote \"Mediana de Tres\"\n    mid = (low + high) // 2\n    # Ordena low, mid, high para encontrar la mediana\n    if arr[low] > arr[mid]:\n        arr[low], arr[mid] = arr[mid], arr[low]\n    if arr[low] > arr[high]:\n        arr[low], arr[high] = arr[high], arr[low]\n    if arr[mid] > arr[high]:\n        arr[mid], arr[high] = arr[high], arr[mid]\n    \n    # El elemento del medio (arr[mid]) es ahora la mediana.\n    # Lo movemos al final menos uno para que act√∫e como pivote.\n    pivot = arr[mid]\n    arr[mid], arr[high - 1] = arr[high - 1], arr[mid]\n\n    # Partici√≥n usando el esquema de Lomuto (modificado)\n    # El pivote est√° en high - 1, por lo que los punteros empiezan en low y high - 2\n    i = low\n    j = high - 1\n    \n    while True:\n        # Encontrar elemento en la izquierda que deba estar en la derecha\n        i += 1\n        while arr[i] < pivot:\n            i += 1\n        # Encontrar elemento en la derecha que deba estar en la izquierda\n        j -= 1\n        while arr[j] > pivot:\n            j -= 1\n        \n        if i >= j:\n            break\n        \n        # Intercambiar elementos\n        arr[i], arr[j] = arr[j], arr[i]\n\n    # Restaurar el pivote a su posici√≥n final\n    arr[i], arr[high - 1] = arr[high - 1], arr[i]\n    \n    return i # Retorna el √≠ndice final del pivote\n\ndef quicksort_optimizado(arr):\n    \"\"\"\n    Funci√≥n principal que ordena un arreglo usando Quicksort optimizado e iterativo.\n    \"\"\"\n    if not arr:\n        return []\n\n    # Pila para simular la recursi√≥n\n    stack = []\n    stack.append((0, len(arr) - 1))\n\n    while stack:\n        low, high = stack.pop()\n        \n        # 2. Si el sub-arreglo es peque√±o, usar Insertion Sort\n        if high - low + 1 < INSERTION_SORT_CUTOFF:\n            insertion_sort(arr, low, high)\n            continue\n\n        # Realizar la partici√≥n\n        pivot_index = partition(arr, low, high)\n\n        # 3. Apilar los sub-problemas, el m√°s grande primero\n        # para mantener la pila peque√±a (O(log n))\n        \n        # Sub-problema de la derecha\n        if pivot_index + 1 < high:\n            right_len = high - (pivot_index + 1)\n        else:\n            right_len = -1\n            \n        # Sub-problema de la izquierda\n        if pivot_index - 1 > low:\n            left_len = (pivot_index - 1) - low\n        else:\n            left_len = -1\n\n        # Apilar el sub-arreglo m√°s grande primero\n        if left_len > right_len:\n            if left_len != -1: stack.append((low, pivot_index - 1))\n            if right_len != -1: stack.append((pivot_index + 1, high))\n        else:\n            if right_len != -1: stack.append((pivot_index + 1, high))\n            if left_len != -1: stack.append((low, pivot_index - 1))\n\n# --- Pruebas y Ejemplo de Uso ---\nif __name__ == \"__main__\":\n    print(\"Probando Quicksort Optimizado...\")\n\n    # Caso 1: Arreglo aleatorio\n    arr1 = [random.randint(1, 1000) for _ in range(50)]\n    print(\"\\nArreglo original (aleatorio):\", arr1)\n    quicksort_optimizado(arr1)\n    print(\"Arreglo ordenado:\", arr1)\n    assert arr1 == sorted(arr1)\n\n    # Caso 2: Arreglo ya ordenado (peor caso para Quicksort ingenuo)\n    arr2 = list(range(30))\n    print(\"\\nArreglo original (ordenado):\", arr2)\n    quicksort_optimizado(arr2)\n    print(\"Arreglo ordenado:\", arr2)\n    assert arr2 == sorted(arr2)\n\n    # Caso 3: Arreglo en orden inverso\n    arr3 = list(range(20, 0, -1))\n    print(\"\\nArreglo original (inverso):\", arr3)\n    quicksort_optimizado(arr3)\n    print(\"Arreglo ordenado:\", arr3)\n    assert arr3 == sorted(arr3)\n\n    # Caso 4: Arreglo con elementos duplicados\n    arr4 = [5, 2, 8, 5, 9, 2, 8, 5, 1, 5]\n    print(\"\\nArreglo original (duplicados):\", arr4)\n    quicksort_optimizado(arr4)\n    print(\"Arreglo ordenado:\", arr4)\n    assert arr4 == sorted(arr4)\n    \n    print(\"\\n¬°Todas las pruebas pasaron con √©xito!\")\n```\n\n---\n\n### An√°lisis de Complejidad\n\n#### **Complejidad Temporal (Tiempo de Ejecuci√≥n)**\n\n*   **Mejor Caso: O(n log n)**\n    *   Ocurre cuando el pivote elegido divide el arreglo en dos mitades de tama√±o casi igual en cada paso.\n    *   La profundidad de la recursi√≥n (o de la pila iterativa) es `log‚ÇÇ(n)`. En cada nivel de profundidad, se realizan `n` comparaciones y intercambios en total. Por lo tanto, la complejidad es `n * log n`.\n    *   Nuestra optimizaci√≥n de \"mediana de tres\" hace que este caso sea mucho m√°s probable.\n\n*   **Caso Promedio: O(n log n)**\n    *   Incluso si las particiones no son perfectamente equilibradas, estad√≠sticamente se mantiene un buen balance. Se puede demostrar matem√°ticamente que el rendimiento promedio sigue siendo O(n log n), lo que hace a Quicksort tan popular.\n\n*   **Peor Caso: O(n¬≤)**\n    *   En un Quicksort **ingenuo**, esto ocurre cuando el",
      "score": 1.0,
      "response_time": 35.91503381729126,
      "cost": 0.03956250000000001,
      "tokens_used": 3972,
      "success": true,
      "error": null
    },
    {
      "model": "Gemini 2.5 Pro",
      "domain": "programming",
      "query": "Crea una funci√≥n que detecte si un grafo es bipartito usando BFS",
      "response": "¬°Claro que s√≠! Aqu√≠ tienes una explicaci√≥n detallada y el c√≥digo de una funci√≥n en Python que utiliza el algoritmo de B√∫squeda en Anchura (BFS) para determinar si un grafo es bipartito.\n\n### ¬øQu√© es un Grafo Bipartito?\n\nUn grafo es **bipartito** si sus v√©rtices se pueden dividir en dos conjuntos disjuntos e independientes, digamos `A` y `B`, de tal manera que cada arista del grafo conecta un v√©rtice de `A` con un v√©rtice de `B`. En otras palabras, no hay ninguna arista que conecte dos v√©rtices del mismo conjunto.\n\nUna propiedad clave que usaremos es: **Un grafo es bipartito si y solo si no contiene ciclos de longitud impar.**\n\n### La Estrategia: Coloreado con BFS\n\nLa idea es intentar \"colorear\" el grafo con dos colores (por ejemplo, 1 y -1). Si logramos colorear todo el grafo sin conflictos, es bipartito.\n\nEl algoritmo funciona as√≠:\n1.  **Inicializaci√≥n**: Creamos un array o diccionario `colores` para almacenar el color de cada v√©rtice. Inicialmente, ning√∫n v√©rtice tiene color (podemos usar `0` o `None` para indicar \"sin color\").\n2.  **Recorrer Componentes**: Como el grafo puede estar desconectado (tener varias componentes conexas), recorremos todos los v√©rtices. Si un v√©rtice a√∫n no ha sido coloreado, iniciamos un BFS desde √©l.\n3.  **BFS y Coloreado**:\n    *   Empezamos en un nodo de origen y le asignamos el primer color (ej. `1`). Lo a√±adimos a una cola.\n    *   Mientras la cola no est√© vac√≠a, sacamos un v√©rtice `u`.\n    *   Para cada vecino `v` de `u`:\n        *   **Si `v` no tiene color**: Le asignamos el color opuesto al de `u` (si `u` es `1`, `v` ser√° `-1`) y lo a√±adimos a la cola.\n        *   **Si `v` ya tiene color**: Comprobamos si su color es el mismo que el de `u`. Si lo es, hemos encontrado un conflicto (una arista que conecta dos nodos del mismo color). Esto significa que el grafo no es bipartito, y podemos detenernos y devolver `False`.\n4.  **Resultado**: Si completamos el recorrido de todos los componentes sin encontrar ning√∫n conflicto, el grafo es bipartito y devolvemos `True`.\n\n### Implementaci√≥n en Python\n\nUsaremos una lista de adyacencia para representar el grafo. Por ejemplo, `graph[i]` ser√° una lista de los vecinos del v√©rtice `i`.\n\n```python\nfrom collections import deque\n\ndef es_bipartito(graph):\n    \"\"\"\n    Detecta si un grafo es bipartito usando BFS.\n\n    Args:\n        graph (list[list[int]]): El grafo representado como una lista de adyacencia.\n                                 Se asume que los v√©rtices est√°n numerados de 0 a n-1.\n\n    Returns:\n        bool: True si el grafo es bipartito, False en caso contrario.\n    \"\"\"\n    num_vertices = len(graph)\n    # Array para almacenar los colores de los v√©rtices.\n    # 0: sin color, 1: color A, -1: color B\n    colores = [0] * num_vertices\n\n    # Recorremos todos los v√©rtices para manejar grafos no conexos\n    for i in range(num_vertices):\n        # Si el v√©rtice no ha sido coloreado, iniciamos un BFS desde √©l\n        if colores[i] == 0:\n            # Cola para el BFS\n            queue = deque()\n\n            # Coloreamos el nodo de inicio y lo a√±adimos a la cola\n            colores[i] = 1\n            queue.append(i)\n\n            while queue:\n                u = queue.popleft()\n\n                # Revisamos todos los vecinos del v√©rtice actual 'u'\n                for v in graph[u]:\n                    # Si el vecino 'v' no ha sido coloreado\n                    if colores[v] == 0:\n                        # Le asignamos el color opuesto al de 'u'\n                        colores[v] = -colores[u]\n                        queue.append(v)\n                    # Si el vecino 'v' ya tiene color y es el mismo que 'u'\n                    elif colores[v] == colores[u]:\n                        # ¬°Conflicto! El grafo no es bipartito.\n                        print(f\"Conflicto encontrado: La arista ({u}, {v}) conecta dos nodos del mismo color.\")\n                        return False\n\n    # Si el bucle termina sin encontrar conflictos, el grafo es bipartito\n    return True\n\n```\n\n### C√≥mo Usar la Funci√≥n\n\nAqu√≠ tienes algunos ejemplos de c√≥mo usar la funci√≥n con diferentes tipos de grafos.\n\n**Ejemplo 1: Grafo Bipartito**\n\nEste grafo se puede dividir en los conjuntos `{0, 2}` y `{1, 3}`.\n\n```\n0 --- 1\n|     |\n3 --- 2\n```\n\n```python\n# Grafo bipartito (un cuadrado)\ngrafo_bipartito = [\n    [1, 3],    # Vecinos del nodo 0\n    [0, 2],    # Vecinos del nodo 1\n    [1, 3],    # Vecinos del nodo 2\n    [0, 2]     # Vecinos del nodo 3\n]\n\nprint(f\"¬øEl grafo 1 es bipartito? {es_bipartito(grafo_bipartito)}\")\n# Salida esperada: ¬øEl grafo 1 es bipartito? True\n```\n\n**Ejemplo 2: Grafo No Bipartito**\n\nEste grafo contiene un ciclo de longitud 3 (0-1-2-0), que es impar.\n\n```\n0 --- 1\n|  /\n2\n```\n\n```python\n# Grafo no bipartito (un tri√°ngulo)\ngrafo_no_bipartito = [\n    [1, 2],    # Vecinos del nodo 0\n    [0, 2],    # Vecinos del nodo 1\n    [0, 1]     # Vecinos del nodo 2\n]\n\nprint(f\"¬øEl grafo 2 es bipartito? {es_bipartito(grafo_no_bipartito)}\")\n# Salida esperada:\n# Conflicto encontrado: La arista (1, 2) conecta dos nodos del mismo color.\n# ¬øEl grafo 2 es bipartito? False\n```\n\n**Ejemplo 3: Grafo Bipartito y No Conexo**\n\nEste grafo tiene dos componentes, y ambas son bipartitas.\n\n```\n0 --- 1      3 --- 4\n```\n\n```python\n# Grafo no conexo pero bipartito\ngrafo_no_conexo = [\n    [1],       # Vecinos de 0\n    [0],       # Vecinos de 1\n    [],        # Vecinos de 2 (nodo aislado)\n    [4],       # Vecinos de 3\n    [3]        # Vecinos de 4\n]\n\nprint(f\"¬øEl grafo 3 es bipartito? {es_bipartito(grafo_no_conexo)}\")\n# Salida esperada: ¬øEl grafo 3 es bipartito? True\n```\n\n### Complejidad\n\n*   **Complejidad Temporal**: **O(V + E)**, donde `V` es el n√∫mero de v√©rtices y `E` es el n√∫mero de aristas. Esto se debe a que cada v√©rtice y cada arista se visitan una sola vez durante el recorrido BFS.\n*   **Complejidad Espacial**: **O(V)**, para almacenar el array de `colores` y la `cola` del BFS",
      "score": 1.0,
      "response_time": 33.55101680755615,
      "cost": 0.04034,
      "tokens_used": 4048,
      "success": true,
      "error": null
    },
    {
      "model": "Gemini 2.5 Pro",
      "domain": "programming",
      "query": "Desarrolla un sistema de cach√© LRU con complejidad O(1) para todas las operaciones",
      "response": "¬°Excelente! Desarrollar un cach√© LRU (Least Recently Used) con complejidad O(1) es un problema cl√°sico de dise√±o de sistemas y estructuras de datos. La clave para lograr la complejidad O(1) es combinar dos estructuras de datos de manera inteligente.\n\n### El Concepto Clave: La Combinaci√≥n M√°gica\n\nPara cumplir con los requisitos, necesitamos realizar las siguientes operaciones en tiempo constante (O(1)):\n\n1.  **`get(key)`**: Obtener el valor de una clave.\n2.  **`put(key, value)`**: Insertar o actualizar una clave.\n3.  **Evicci√≥n**: Encontrar y eliminar el elemento menos usado cuando el cach√© est√° lleno.\n\nNinguna estructura de datos por s√≠ sola puede hacer todo esto en O(1):\n*   Un **HashMap (o Diccionario)** nos da `get` y `put` en O(1), pero no nos dice cu√°l es el elemento menos usado sin recorrerlo todo (O(n)).\n*   Una **Lista Enlazada** puede mantener el orden de uso (moviendo elementos al frente), pero encontrar un elemento (`get`) requiere recorrerla (O(n)).\n\nLa soluci√≥n es combinar ambas:\n\n1.  **Un Diccionario (HashMap)**: Para el acceso instant√°neo a los datos. Almacenar√° la `clave` y un **puntero/referencia al nodo** en la lista enlazada.\n    *   `{ clave -> Nodo }`\n2.  **Una Lista Doblemente Enlazada**: Para mantener el orden de uso. Los elementos m√°s recientes estar√°n al frente (cabeza) y los menos recientes al final (cola). Usar una lista *doblemente* enlazada es crucial porque nos permite eliminar un nodo en O(1) si tenemos una referencia a √©l.\n\n### C√≥mo Funciona la L√≥gica\n\n*   **La lista enlazada** ordena los elementos por uso. La cabeza de la lista es el elemento **M√°s Recientemente Usado** (MRU) y la cola es el **Menos Recientemente Usado** (LRU).\n*   **El diccionario** nos da la ubicaci√≥n de cualquier nodo en la lista en O(1), para que no tengamos que buscarlo linealmente.\n\n#### Flujo de las Operaciones:\n\n*   **`get(key)`**:\n    1.  Busca la `clave` en el diccionario. Si no existe, retorna -1.\n    2.  Si existe, obtiene la referencia al `nodo` desde el diccionario.\n    3.  **Mueve este `nodo` al frente de la lista enlazada**, ya que ahora es el m√°s recientemente usado.\n    4.  Retorna el valor del `nodo`.\n    *   *Complejidad: O(1) para el diccionario + O(1) para mover el nodo = **O(1)***\n\n*   **`put(key, value)`**:\n    1.  Busca la `clave` en el diccionario.\n    2.  **Si la clave ya existe**:\n        a. Obtiene la referencia al `nodo`.\n        b. Actualiza el `valor` del nodo.\n        c. **Mueve este `nodo` al frente de la lista**.\n    3.  **Si la clave es nueva**:\n        a. **Verifica si el cach√© est√° lleno**.\n           i. Si est√° lleno, **elimina el √∫ltimo nodo de la lista** (el LRU).\n           ii. Tambi√©n elimina la clave correspondiente a ese nodo del diccionario.\n        b. Crea un **nuevo `nodo`** con la clave y el valor.\n        c. **A√±ade el nuevo `nodo` al frente de la lista**.\n        d. **A√±ade la nueva `clave` y la referencia al `nodo` en el diccionario**.\n    *   *Complejidad: Todas las sub-operaciones (b√∫squeda en diccionario, a√±adir/eliminar al frente/final de la lista) son O(1). Por lo tanto, la complejidad total es **O(1)***.\n\n### Implementaci√≥n en Python\n\nAqu√≠ tienes una implementaci√≥n completa y comentada en Python, que ilustra perfectamente el concepto.\n\n```python\n# Paso 1: Definir el Nodo para la Lista Doblemente Enlazada\nclass Node:\n    \"\"\"\n    Nodo de una lista doblemente enlazada.\n    Almacena clave y valor para poder eliminar la clave del diccionario al hacer evicci√≥n.\n    \"\"\"\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\n# Paso 2: Definir la clase LRUCache\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}  # Diccionario: clave -> Nodo\n\n        # Usamos nodos \"dummy\" (centinelas) para la cabeza y la cola.\n        # Esto simplifica enormemente la l√≥gica de inserci√≥n/eliminaci√≥n,\n        # ya que nunca tenemos que preocuparnos por listas vac√≠as o de un solo elemento.\n        self.head = Node(0, 0) # Nodo m√°s reciente est√° despu√©s de head\n        self.tail = Node(0, 0) # Nodo menos reciente est√° antes de tail\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    # --- M√©todos auxiliares para manipular la lista enlazada ---\n\n    def _remove_node(self, node: Node):\n        \"\"\"Elimina un nodo existente de la lista enlazada.\"\"\"\n        prev_node = node.prev\n        next_node = node.next\n        prev_node.next = next_node\n        next_node.prev = prev_node\n\n    def _add_to_front(self, node: Node):\n        \"\"\"A√±ade un nodo justo despu√©s del nodo 'head' (al frente).\"\"\"\n        # El \"frente\" es el espacio entre self.head y self.head.next\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n\n    def _move_to_front(self, node: Node):\n        \"\"\"Mueve un nodo existente al frente de la lista.\"\"\"\n        self._remove_node(node)\n        self._add_to_front(node)\n\n    # --- M√©todos p√∫blicos de la API del Cach√© ---\n\n    def get(self, key: int) -> int:\n        \"\"\"\n        Obtiene el valor de una clave. Si existe, la mueve al frente.\n        Retorna -1 si la clave no se encuentra.\n        \"\"\"\n        if key in self.cache:\n            node = self.cache[key]\n            # La clave ha sido accedida, as√≠ que es la m√°s reciente.\n            self._move_to_front(node)\n            return node.value\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        \"\"\"\n        Inserta o actualiza una clave-valor.\n        Si la clave es nueva y el cach√© est√°",
      "score": 1.0,
      "response_time": 34.3718056678772,
      "cost": 0.03995375,
      "tokens_used": 4012,
      "success": true,
      "error": null
    },
    {
      "model": "Gemini 2.5 Pro",
      "domain": "reasoning",
      "query": "Analiza la complejidad computacional del problema del viajante y prop√≥n una soluci√≥n aproximada",
      "response": "¬°Excelente pregunta! El Problema del Viajante (TSP, por sus siglas en ingl√©s, *Traveling Salesperson Problem*) es uno de los problemas m√°s famosos y estudiados en el campo de la inform√°tica y la optimizaci√≥n.\n\nA continuaci√≥n, se presenta un an√°lisis detallado de su complejidad y una propuesta de soluci√≥n aproximada.\n\n---\n\n### 1. An√°lisis de la Complejidad Computacional del Problema del Viajante\n\n#### ¬øQu√© es el Problema del Viajante?\n\nEl problema se enuncia de forma sencilla: dado un conjunto de ciudades y las distancias entre cada par de ellas, ¬øcu√°l es la ruta m√°s corta posible que visita cada ciudad exactamente una vez y regresa a la ciudad de origen?\n\n#### La Explosi√≥n Combinatoria\n\nPara entender su complejidad, analicemos el n√∫mero de posibles rutas. Si tenemos **N** ciudades:\n\n1.  Podemos empezar en cualquiera de las N ciudades.\n2.  Desde all√≠, tenemos N-1 opciones para la segunda ciudad.\n3.  Luego, N-2 para la tercera, y as√≠ sucesivamente.\n\nEsto nos da un total de `N * (N-1) * (N-2) * ... * 1 = N!` (N factorial) permutaciones.\n\nSin embargo, como la ruta es un ciclo, el punto de partida no importa (la ruta A‚ÜíB‚ÜíC‚ÜíA es la misma que B‚ÜíC‚ÜíA‚ÜíB). Esto nos permite fijar una ciudad de inicio, reduciendo las rutas a `(N-1)!`.\n\nAdem√°s, la direcci√≥n del recorrido tampoco importa (A‚ÜíB‚ÜíC‚ÜíA es igual de larga que A‚ÜíC‚ÜíB‚ÜíA). Por lo tanto, podemos dividir el n√∫mero de rutas por 2.\n\nEl n√∫mero total de rutas √∫nicas es: **(N-1)! / 2**\n\n#### Complejidad y Clase NP-dif√≠cil\n\nEl problema del viajante pertenece a la clase de complejidad **NP-dif√≠cil** (*NP-hard*). Esto significa que:\n\n*   **No se conoce ning√∫n algoritmo que pueda encontrar la soluci√≥n √≥ptima en tiempo polin√≥mico.** Es decir, no hay un algoritmo \"eficiente\" que resuelva el problema para cualquier n√∫mero de ciudades.\n*   El tiempo de ejecuci√≥n de los algoritmos exactos (que garantizan la soluci√≥n √≥ptima) crece de forma exponencial o factorial con el n√∫mero de ciudades (N).\n\nPara ilustrar el crecimiento (\"explosi√≥n combinatoria\"), veamos c√≥mo aumenta el n√∫mero de rutas:\n\n| N¬∫ de Ciudades (N) | N¬∫ de Rutas √önicas ((N-1)! / 2) | Tiempo de C√≥mputo (aprox. en un PC moderno) |\n| :----------------- | :-------------------------------- | :----------------------------------------- |\n| 5                  | 12                                | Instant√°neo                                |\n| 10                 | 181,440                           | Menos de un segundo                        |\n| 15                 | 653,837,184,000                   | Minutos / Horas                            |\n| 20                 | 1.2 x 10¬π‚Å∑ (120 mil billones)     | Miles de a√±os                              |\n| 25                 | 3.1 x 10¬≤¬≥                        | M√°s que la edad del universo               |\n\n**Conclusi√≥n del an√°lisis:** Para un n√∫mero peque√±o de ciudades (hasta ~15), es factible encontrar la soluci√≥n exacta por fuerza bruta (probando todas las rutas). Para problemas del mundo real (log√≠stica, dise√±o de chips, secuenciaci√≥n de ADN) que pueden involucrar cientos o miles de \"ciudades\", es computacionalmente imposible garantizar la soluci√≥n √≥ptima. Por ello, necesitamos soluciones aproximadas.\n\n---\n\n### 2. Propuesta de Soluci√≥n Aproximada (Heur√≠stica)\n\nDado que encontrar la soluci√≥n perfecta es inviable, recurrimos a **heur√≠sticas**: algoritmos que no garantizan la mejor soluci√≥n, pero que encuentran una soluci√≥n \"suficientemente buena\" en un tiempo razonable.\n\nAqu√≠ propongo una de las heur√≠sticas m√°s intuitivas y f√°ciles de implementar: el **Algoritmo del Vecino m√°s Cercano** (*Nearest Neighbour Algorithm*).\n\n#### Algoritmo del Vecino m√°s Cercano\n\nEs un algoritmo \"voraz\" (*greedy*), ya que en cada paso toma la decisi√≥n que parece mejor en ese momento, sin pensar en las consecuencias a largo plazo.\n\n**Pasos del algoritmo:**\n\n1.  **Elegir un punto de partida:** Selecciona una ciudad de inicio al azar.\n2.  **Buscar el vecino m√°s cercano:** Desde la ciudad actual, encuentra la ciudad no visitada que est√© m√°s cerca.\n3.  **Moverse a esa ciudad:** A√±ade esa ciudad a la ruta y m√°rcala como visitada.\n4.  **Repetir:** Repite los pasos 2 y 3 hasta que todas las ciudades hayan sido visitadas.\n5.  **Regresar al inicio:** Una vez visitadas todas las ciudades, a√±ade el trayecto desde la √∫ltima ciudad hasta la ciudad de inicio para cerrar el ciclo.\n\n**Ventajas:**\n\n*   **Muy r√°pido:** Su complejidad computacional es **O(N¬≤)**, lo cual es extremadamente eficiente en comparaci√≥n con O(N!).\n*   **F√°cil de implementar:** La l√≥gica es muy sencilla de programar.\n*   **Intuitivo:** Se asemeja a c√≥mo una persona podr√≠a planificar una ruta de forma improvisada.\n\n**Desventajas:**\n\n*   **No garantiza la optimalidad:** Las decisiones \"voraces\" iniciales pueden llevar a situaciones muy malas al final del recorrido. Por ejemplo, puede que al final te veas forzado a hacer un salto muy largo porque es la √∫nica opci√≥n que queda.\n*   **Sensible al punto de partida:** La ruta final y su coste dependen en gran medida de la ciudad con la que se empieza. Una buena pr√°ctica es ejecutar el algoritmo varias veces, empezando cada vez en una ciudad diferente, y quedarse con la mejor ruta encontrada.\n\n#### Ejemplo Pr√°ctico (Vecino m√°s Cercano)\n\nImaginemos 4 ciudades (A, B, C, D) con la siguiente matriz de distancias:\n\n|       | A    | B    | C    | D    |\n| :---- | :--- | :--- | :--- | :--- |\n| **A** | 0    | 15   | 10   | 20   |\n| **B** | 15   | 0    | 12   | 25   |\n| **C** | 10   | 12   | 0    | 18   |\n| **D** | 20   | 25   | 18   | 0    |\n\n**Ejecuci√≥n del algoritmo:**\n\n1.  **Inicio:** Empezamos en la ciudad **A**.\n    *   Ruta actual: `A`\n2.  **Paso 1:** Desde A, los vecinos no visitados son B (15), C (10), D (20). El m√°s cercano es **C**.\n    *   Ruta actual: `A ‚Üí C`\n3.  **Paso 2:** Desde C, los vecinos no visitados son B (12) y D (18). El m√°s cercano es **B**.\n    *   Ruta actual: `A ‚Üí C ‚Üí B`\n4.  **Paso 3:** Desde B, el √∫nico vecino no visitado es **D**.\n    *   Ruta actual: `A ‚Üí C ‚Üí B ‚Üí D`\n5.  **Paso 4:** Todas las ciudades han sido visitadas. Volvemos al inicio (**A**).\n    *   Ruta final: `A ‚Üí C ‚Üí B ‚Üí D ‚Üí A`\n\n**C√°lculo del coste total:**\nDistancia(A‚ÜíC) + Distancia(C‚ÜíB) + Distancia(B‚ÜíD) + Distancia(D‚ÜíA) = 10 + 12 + 25 + 20 = **67**\n\nEsta es una soluci√≥n buena y r√°pida. Sin embargo, la ruta √≥ptima en este caso es `A ‚Üí B ‚Üí C ‚Üí D ‚Üí A`, con un coste de 15 + 12 + 18 + 20 = **65**. El algoritmo voraz no encontr√≥ la soluci√≥n perfecta, pero se acerc√≥ bastante.\n\n### Otras Soluciones Aproximadas (Menci√≥n)\n\nPara obtener mejores resultados que el vecino m√°s cercano, se pueden usar heur√≠sticas m√°s avanzadas:\n\n*   **Inserci√≥n m√°s barata (*Cheapest Insertion*):** Se empieza con una ruta peque√±a (ej. dos ciudades) y se va insertando la ciudad restante que a√±ada el menor coste posible a la ruta existente.\n*   **Optimizaci√≥n 2-opt:** Se parte de una ruta (generada, por ejemplo, con el vecino m√°s cercano) y se intenta mejorarla sistem√°ticamente. Se toman dos aristas de la ruta que se crucen y se reconectan los nodos para ver si el nuevo camino es m√°s corto. Se repite hasta que no se puedan hacer m√°s mejoras.\n*   **Metaheur√≠sticas:** Para problemas muy complejos, se usan algoritmos como **Recocido Simulado (*Simulated Annealing*)**, **Algoritmos Gen√©ticos** o **Optimizaci√≥n por Colonia de Hormigas**, que exploran el espacio de soluciones de manera m√°s inteligente para evitar quedarse atascados en √≥ptimos locales.\n\n### Resumen Final\n\n| Caracter√≠stica | An√°lisis de Complejidad (Soluci√≥n Exacta) | Soluci√≥n Aproximada (Vecino m√°s Cercano) |\n| :--- | :--- | :--- |\n| **Objetivo** | Encontrar la ruta **√≥ptima** garantizada. | Encontrar una ruta **buena** r√°pidamente. |\n| **Complejidad** | **NP-dif√≠cil** (O(N!)) | **Polin√≥mica** (O(N¬≤)) |\n| **Viabilidad** | Inviable para N > 20-25. | Viable para miles de ciudades. |\n| **Calidad** | Perfecta (100% √≥ptima). | Sub√≥ptima (generalmente un 15-25% peor que la √≥ptima). |\n| **Uso** | Acad√©mico, problemas muy peque√±os. | Log√≠stica, fabricaci√≥n, gen√≥mica, aplicaciones del mundo real",
      "score": 0.7999999999999999,
      "response_time": 35.67206859588623,
      "cost": 0.03950125,
      "tokens_used": 3965,
      "success": true,
      "error": null
    },
    {
      "model": "Gemini 2.5 Pro",
      "domain": "reasoning",
      "query": "Explica paso a paso c√≥mo resolver el problema de las 8 reinas usando backtracking",
      "response": "¬°Claro que s√≠! Explicar el problema de las 8 reinas con backtracking es un ejemplo cl√°sico y excelente para entender este poderoso algoritmo.\n\nAqu√≠ tienes una explicaci√≥n detallada, paso a paso.\n\n### 1. El Problema: ¬øQu√© son las 8 Reinas?\n\nEl objetivo es simple: colocar 8 reinas de ajedrez en un tablero de 8x8 de tal manera que **ninguna reina pueda atacar a otra**.\n\nRecordemos las reglas de ataque de una reina:\n*   Puede atacar a cualquier pieza en la misma **fila**.\n*   Puede atacar a cualquier pieza en la misma **columna**.\n*   Puede atacar a cualquier pieza en la misma **diagonal** (en ambas direcciones).\n\nEsto significa que en una soluci√≥n v√°lida, solo puede haber una reina por fila, una por columna y una por diagonal.\n\n---\n\n### 2. La Estrategia: ¬øPor qu√© Backtracking?\n\nImaginar todas las combinaciones posibles de colocar 8 reinas en 64 casillas es una locura (m√°s de 4 mil millones de formas). Necesitamos un m√©todo m√°s inteligente.\n\nEl **Backtracking** (o \"vuelta atr√°s\") es perfecto para esto. La idea es construir la soluci√≥n paso a paso y, en cuanto nos damos cuenta de que una decisi√≥n nos lleva a un callej√≥n sin salida, \"damos un paso atr√°s\" (backtrack) y probamos una alternativa.\n\n**Analog√≠a simple:** Imagina que est√°s en un laberinto.\n1.  Avanzas por un camino.\n2.  En cada bifurcaci√≥n, eliges una direcci√≥n (por ejemplo, siempre a la derecha).\n3.  Si llegas a un callej√≥n sin salida, no te rindes. Vuelves a la √∫ltima bifurcaci√≥n donde tomaste una decisi√≥n y pruebas el otro camino que no hab√≠as tomado.\n4.  Repites este proceso hasta encontrar la salida.\n\nEso es exactamente lo que haremos con las reinas.\n\n---\n\n### 3. El Proceso Paso a Paso\n\nVamos a simplificar el problema con una regla clave: **colocaremos solo una reina por columna**. Esto ya nos soluciona el conflicto de columnas y reduce enormemente las posibilidades. Empezaremos por la columna 0, luego la 1, la 2, y as√≠ sucesivamente.\n\n#### **Paso 1: Empezar con un tablero vac√≠o**\n\nComenzamos en la **columna 0**. Nuestro objetivo es encontrar una fila segura en esta columna para colocar la primera reina.\n\n```\n  0 1 2 3 4 5 6 7  (Columnas)\n0 . . . . . . . .\n1 . . . . . . . .\n2 . . . . . . . .\n3 . . . . . . . .\n4 . . . . . . . .\n5 . . . . . . . .\n6 . . . . . . . .\n7 . . . . . . . .\n(Filas)\n```\n\n#### **Paso 2: Colocar la primera reina y avanzar**\n\nIntentamos colocar la reina en la primera fila disponible de la **columna 0**: la casilla `(fila=0, columna=0)`.\n\n*   **¬øEs una posici√≥n segura?** S√≠, el tablero est√° vac√≠o, as√≠ que no hay ninguna otra reina que la amenace.\n*   **Acci√≥n:** Colocamos la reina (`Q`) y avanzamos a la siguiente columna (**columna 1**).\n\n```\n  0 1 2 3 4 5 6 7\n0 Q . . . . . . .\n1 . . . . . . . .\n2 . . . . . . . .\n3 . . . . . . . .\n4 . . . . . . . .\n5 . . . . . . . .\n6 . . . . . . . .\n7 . . . . . . . .\n```\n\n#### **Paso 3: Intentar colocar la segunda reina**\n\nAhora estamos en la **columna 1**. Debemos encontrar una fila segura.\n\n*   **¬øIntentamos en la fila 0?** No, est√° atacada por la reina en `(0,0)`.\n*   **¬øIntentamos en la fila 1?** No, est√° en la misma diagonal que la reina en `(0,0)`.\n*   **¬øIntentamos en la fila 2?** ¬°S√≠! Esta casilla `(2,1)` es segura. No hay ninguna reina en la fila 2, ni en la diagonal.\n*   **Acci√≥n:** Colocamos la reina y avanzamos a la **columna 2**.\n\n```\n  0 1 2 3 4 5 6 7\n0 Q . . . . . . .\n1 . . . . . . . .\n2 . Q . . . . . .\n3 . . . . . . . .\n4 . . . . . . . .\n5 . . . . . . . .\n6 . . . . . . . .\n7 . . . . . . . .\n```\n\n#### **Paso 4: Continuar el proceso y encontrar un conflicto**\n\nSeguimos este proceso. Colocamos reinas en la columna 2, 3, 4... hasta que llegamos a un punto donde no podemos colocar una reina.\n\nPor ejemplo, supongamos que hemos llegado a esta configuraci√≥n y ahora intentamos colocar una reina en la **columna 5**:\n\n```\n  0 1 2 3 4 5 6 7\n0 Q . . . . . . .\n1 . . . Q . . . .\n2 . . . . . . . .\n3 . Q . . . . . .\n4 . . . . Q . . .\n5 . . . . . . . .\n6 . . . . . . . .\n7 . . . . . . . .\n```\n\nAl revisar todas las filas (de 0 a 7) en la **columna 5**, nos damos cuenta de que **TODAS est√°n atacadas** por las reinas ya colocadas. ¬°Hemos llegado a un callej√≥n sin salida!\n\n#### **Paso 5: ¬°El Backtrack! (La Vuelta Atr√°s)**\n\nAqu√≠ es donde ocurre la magia. Como no podemos colocar una reina en la columna 5, significa que la decisi√≥n que tomamos en la **columna 4** fue incorrecta.\n\n1.  **Retrocedemos a la columna 4.**\n2.  **Quitamos la reina** que hab√≠amos colocado all√≠ (en la casilla `(4,4)`).\n3.  **Intentamos encontrar una nueva posici√≥n segura** para la reina en la columna 4, a partir de la fila siguiente a la que ya probamos (es decir, desde la fila 5 en adelante).\n\nSupongamos que no hay m√°s posiciones seguras en la columna 4. ¬øQu√© hacemos? ¬°Volvemos a hacer backtrack!\n\n1.  **Retrocedemos a la columna 3.**\n2.  **Quitamos la reina** de la columna 3.\n3.  **Intentamos encontrar una nueva posici√≥n segura** en la columna 3.\n\nEste proceso de \"quitar la pieza y probar la siguiente opci√≥n en la columna anterior\" es el coraz√≥n del backtracking.\n\n#### **Paso 6: Encontrar una soluci√≥n**\n\nContinuamos este proceso de colocar, avanzar, y si hay un problema, retroceder.\n\nCuando logramos colocar con √©xito una reina en la √∫ltima columna (**columna 7**), significa que hemos encontrado una soluci√≥n completa.\n\n```\n  0 1 2 3 4 5 6 7\n0 . . . . Q . . .\n1 . . . . . . Q .\n2 . . Q . . . . .\n3 Q . . . . . . .\n4 . . . . . Q . .\n5 . Q . . . . . .\n6 . . . . . . . Q\n7 . . . Q . . . .\n(Una de las 92 soluciones posibles)\n```\n\n**¬øY si queremos todas las soluciones?**\nDespu√©s de encontrar una soluci√≥n, simplemente pretendemos que fue un \"callej√≥n sin salida\". Hacemos backtrack desde la √∫ltima reina colocada (en la columna 7) para forzar al algoritmo a buscar otras configuraciones.\n\n---\n\n### 4. Pseudoc√≥digo del Algoritmo\n\nPara que quede m√°s claro, as√≠ se ver√≠a en c√≥digo (de forma simplificada).\n\n```\n// Funci√≥n principal que inicia el proceso\nfuncion resolver_8_reinas():\n  // Creamos un tablero vac√≠o de 8x8\n  tablero = crear_tablero_vacio(8)\n  // Empezamos a resolver desde la primera columna (columna 0)\n  si resolver_desde_columna(tablero, 0) == verdadero:\n    imprimir_solucion(tablero)\n  sino:\n    imprimir \"No se encontr√≥ soluci√≥n\"\n\n// Funci√≥n recursiva que implementa el backtracking\nfuncion resolver_desde_columna(tablero, col):\n  // CASO BASE: Si ya hemos pasado la √∫ltima columna, hemos encontrado una soluci√≥n\n  si col >= 8:\n    return verdadero\n\n  // Intentamos colocar una reina en cada fila de la columna actual\n  para cada fila desde 0 hasta 7:\n    // 1. COMPROBAR: ¬øEs seguro colocar una reina aqu√≠?\n    si es_seguro(tablero, fila, col):\n      // 2. ELEGIR: Colocamos la reina\n      tablero[fila][col] = 'Q'\n\n      // 3. EXPLORAR: Llamada recursiva para la siguiente columna\n      si resolver_desde_columna(tablero, col + 1) == verdadero:\n        return verdadero // ¬°Soluci√≥n encontrada! Propagamos el √©xito hacia atr√°s\n\n      // 4. BACKTRACK: Si la llamada anterior no llev√≥ a una soluci√≥n,\n      // quitamos la reina y probamos la siguiente fila.\n      tablero[fila][col] = '.' // \"Deshacemos",
      "score": 0.85,
      "response_time": 37.42702555656433,
      "cost": 0.039642500000000004,
      "tokens_used": 3980,
      "success": true,
      "error": null
    },
    {
      "model": "Gemini 2.5 Pro",
      "domain": "reasoning",
      "query": "Demuestra por qu√© el algoritmo de Dijkstra no funciona con pesos negativos",
      "response": "",
      "score": 0.0,
      "response_time": 34.62832236289978,
      "cost": 0.0400075,
      "tokens_used": 4013,
      "success": true,
      "error": null
    },
    {
      "model": "Gemini 2.5 Pro",
      "domain": "mathematics",
      "query": "Demuestra la f√≥rmula de Euler e^(iœÄ) + 1 = 0 usando series de Taylor",
      "response": "¬°Claro que s√≠! La identidad de Euler, **e^(iœÄ) + 1 = 0**, es una de las ecuaciones m√°s famosas y bellas de las matem√°ticas. Demostrarla usando series de Taylor es un ejercicio cl√°sico y muy elegante.\n\nLa demostraci√≥n se basa en probar primero la **F√≥rmula de Euler**: `e^(ix) = cos(x) + i sin(x)`. Una vez que tenemos esta f√≥rmula, la identidad se obtiene de forma muy sencilla.\n\nAqu√≠ tienes la demostraci√≥n paso a paso.\n\n### Paso 1: Escribir las Series de Taylor Fundamentales\n\nPrimero, recordemos las expansiones en series de Taylor (o Maclaurin, que son series de Taylor centradas en 0) para las funciones `e^z`, `cos(x)` y `sin(x)`.\n\n1.  **Serie para la funci√≥n exponencial `e^z`** (v√°lida para cualquier n√∫mero complejo `z`):\n    `e^z = 1 + z + z¬≤/2! + z¬≥/3! + z‚Å¥/4! + ...`\n\n2.  **Serie para la funci√≥n coseno `cos(x)`**:\n    `cos(x) = 1 - x¬≤/2! + x‚Å¥/4! - x‚Å∂/6! + ...`\n\n3.  **Serie para la funci√≥n seno `sin(x)`**:\n    `sin(x) = x - x¬≥/3! + x‚Åµ/5! - x‚Å∑/7! + ...`\n\n### Paso 2: Sustituir `z = ix` en la serie de `e^z`\n\nAhora, tomamos la serie de `e^z` y sustituimos la variable `z` por `ix`, donde `i` es la unidad imaginaria (`i¬≤ = -1`).\n\n`e^(ix) = 1 + (ix) + (ix)¬≤/2! + (ix)¬≥/3! + (ix)‚Å¥/4! + (ix)‚Åµ/5! + ...`\n\n### Paso 3: Simplificar las potencias de `i`\n\nPara simplificar la serie, necesitamos calcular las potencias de `i`. Recordemos el patr√≥n c√≠clico:\n*   `i¬π = i`\n*   `i¬≤ = -1`\n*   `i¬≥ = i¬≤ * i = -i`\n*   `i‚Å¥ = (i¬≤)¬≤ = (-1)¬≤ = 1`\n*   `i‚Åµ = i‚Å¥ * i = i`\n*   ... y as√≠ sucesivamente.\n\nAhora sustituimos estas potencias en la serie de `e^(ix)`:\n\n`e^(ix) = 1 + ix + (-1)x¬≤/2! + (-i)x¬≥/3! + (1)x‚Å¥/4! + (i)x‚Åµ/5! + ...`\n\nSimplificando:\n\n`e^(ix) = 1 + ix - x¬≤/2! - ix¬≥/3! + x‚Å¥/4! + ix‚Åµ/5! - ...`\n\n### Paso 4: Reagrupar los t√©rminos reales e imaginarios\n\nEl siguiente paso es separar los t√©rminos que no tienen `i` (la parte real) de los t√©rminos que s√≠ tienen `i` (la parte imaginaria).\n\n**Parte Real** (t√©rminos sin `i`):\n`1 - x¬≤/2! + x‚Å¥/4! - ...`\n\n**Parte Imaginaria** (t√©rminos con `i`, factorizando `i`):\n`i(x - x¬≥/3! + x‚Åµ/5! - ...)`\n\nJuntando ambas partes, la serie para `e^(ix)` queda as√≠:\n\n`e^(ix) = (1 - x¬≤/2! + x‚Å¥/4! - ...) + i(x - x¬≥/3! + x‚Åµ/5! - ...)`\n\n### Paso 5: Reconocer las series de `cos(x)` y `sin(x)`\n\n¬°Este es el momento clave! Si observamos los t√©rminos agrupados, nos damos cuenta de que son exactamente las series de Taylor para `cos(x)` y `sin(x)` que escribimos en el Paso 1.\n\n*   La parte real `(1 - x¬≤/2! + x‚Å¥/4! - ...)` es la serie de **`cos(x)`**.\n*   La parte entre par√©ntesis de la parte imaginaria `(x - x¬≥/3! + x‚Åµ/5! - ...)` es la serie de **`sin(x)`**.\n\nPor lo tanto, podemos sustituir las series por las funciones que representan.\n\n### Paso 6: Obtener la F√≥rmula de Euler\n\nAl hacer la sustituci√≥n, llegamos a la **F√≥rmula de Euler**:\n\n`e^(ix) = cos(x) + i sin(x)`\n\nEsta f√≥rmula es un resultado incre√≠ble por s√≠ misma, ya que conecta la funci√≥n exponencial con las funciones trigonom√©tricas a trav√©s de los n√∫meros complejos.\n\n### Paso 7: Demostrar la Identidad de Euler\n\nAhora que hemos demostrado la F√≥rmula de Euler, obtener la Identidad de Euler es muy f√°cil. Simplemente sustituimos `x = œÄ` en la f√≥rmula:\n\n`e^(iœÄ) = cos(œÄ) + i sin(œÄ)`\n\nSabemos los valores de `cos(œÄ)` y `sin(œÄ)`:\n*   `cos(œÄ) = -1`\n*   `sin(œÄ) = 0`\n\nSustituyendo estos valores en la ecuaci√≥n:\n\n`e^(iœÄ) = -1 + i(0)`\n`e^(iœÄ) = -1`\n\n### Paso 8: El resultado final\n\nFinalmente, reordenamos la ecuaci√≥n pasando el -1 al otro lado:\n\n`e^(iœÄ) + 1 = 0`\n\nY as√≠ queda demostrada la identidad de Euler utilizando series de Taylor. Este resultado es extraordinario porque relaciona cinco de las constantes matem√°ticas m√°s importantes (`e`, `i`, `œÄ`, `1` y `0`) en una sola y elegante ecuaci√≥n.",
      "score": 0.6,
      "response_time": 28.941625118255615,
      "cost": 0.0311675,
      "tokens_used": 3136,
      "success": true,
      "error": null
    },
    {
      "model": "Gemini 2.5 Pro",
      "domain": "mathematics",
      "query": "Calcula la derivada de la funci√≥n f(x) = ln(sin(x^2)) usando la regla de la cadena",
      "response": "¬°Claro! Vamos a calcular la derivada de `f(x) = ln(sin(x^2))` paso a paso usando la regla de la cadena.\n\nLa regla de la cadena se utiliza cuando tenemos \"funciones anidadas\" (una funci√≥n dentro de otra). En este caso, tenemos tres funciones:\n\n1.  La funci√≥n m√°s externa: **ln(u)**\n2.  La funci√≥n intermedia: **sin(v)**\n3.  La funci√≥n m√°s interna: **x¬≤**\n\nLa regla de la cadena para tres funciones `h(g(k(x)))` dice que la derivada es:\n`f'(x) = h'(g(k(x))) * g'(k(x)) * k'(x)`\n\nEn palabras sencillas: \"la derivada de la funci√≥n de afuera (evaluada en la de adentro) multiplicada por la derivada de la siguiente funci√≥n (evaluada en la m√°s interna) multiplicada por la derivada de la funci√≥n de adentro\".\n\n### Paso 1: Identificar las funciones y sus derivadas\n\n*   **Funci√≥n externa (h):** `h(u) = ln(u)`\n    *   Su derivada es: `h'(u) = 1/u`\n\n*   **Funci√≥n intermedia (g):** `g(v) = sin(v)`\n    *   Su derivada es: `g'(v) = cos(v)`\n\n*   **Funci√≥n interna (k):** `k(x) = x¬≤`\n    *   Su derivada es: `k'(x) = 2x`\n\n### Paso 2: Aplicar la regla de la cadena\n\nAhora, ensamblamos las piezas:\n\n1.  **Derivada de la funci√≥n externa `ln(...)`**: La derivada de `ln(u)` es `1/u`. Mantenemos el argumento original `sin(x^2)` dentro.\n    *   Resultado parcial: `1 / sin(x^2)`\n\n2.  **Multiplicar por la derivada de la funci√≥n intermedia `sin(...)`**: La derivada de `sin(v)` es `cos(v)`. Mantenemos su argumento original `x^2` dentro.\n    *   Resultado parcial: `cos(x^2)`\n\n3.  **Multiplicar por la derivada de la funci√≥n interna `x¬≤`**: La derivada de `x¬≤` es `2x`.\n    *   Resultado parcial: `2x`\n\n### Paso 3: Juntar todo y simplificar\n\nAhora multiplicamos los resultados de cada paso:\n\n`f'(x) = [ 1 / sin(x^2) ] * [ cos(x^2) ] * [ 2x ]`\n\nPodemos reordenar esto para que se vea m√°s claro:\n\n`f'(x) = (2x * cos(x^2)) / sin(x^2)`\n\nFinalmente, podemos simplificar la expresi√≥n usando la identidad trigonom√©trica `cot(A) = cos(A) / sin(A)`. En nuestro caso, `A = x^2`.\n\n`f'(x) = 2x * cot(x^2)`\n\n---\n\n### Resultado Final\n\nLa derivada de la funci√≥n `f(x) = ln(sin(x^2))` es:\n\n**f'(x) = 2x * cot(x^2)**",
      "score": 0.45,
      "response_time": 19.33105182647705,
      "cost": 0.02062375,
      "tokens_used": 2086,
      "success": true,
      "error": null
    },
    {
      "model": "Gemini 2.5 Pro",
      "domain": "mathematics",
      "query": "Resuelve la ecuaci√≥n diferencial dy/dx + 2y = e^(-x) con condici√≥n inicial y(0) = 1",
      "response": "¬°Claro! Vamos a resolver esta ecuaci√≥n diferencial paso a paso.\n\nLa ecuaci√≥n que queremos resolver es:\n$$ \\frac{dy}{dx} + 2y = e^{-x} $$\ncon la condici√≥n inicial $y(0) = 1$.\n\nEsta es una **ecuaci√≥n diferencial lineal de primer orden**. Su forma est√°ndar es:\n$$ \\frac{dy}{dx} + P(x)y = Q(x) $$\n\nEl m√©todo para resolver este tipo de ecuaciones es el del **factor integrante**.\n\n---\n\n### Paso 1: Identificar P(x) y Q(x)\n\nComparando nuestra ecuaci√≥n con la forma est√°ndar, podemos identificar:\n*   $P(x) = 2$\n*   $Q(x) = e^{-x}$\n\n---\n\n### Paso 2: Calcular el factor integrante (Œº)\n\nEl factor integrante, que denotaremos como $\\mu(x)$, se calcula con la f√≥rmula:\n$$ \\mu(x) = e^{\\int P(x)dx} $$\n\nSustituimos $P(x) = 2$:\n$$ \\mu(x) = e^{\\int 2 dx} = e^{2x} $$\n(Nota: No es necesario a√±adir la constante de integraci√≥n C en este paso).\n\nNuestro factor integrante es $\\mu(x) = e^{2x}$.\n\n---\n\n### Paso 3: Multiplicar la ecuaci√≥n original por el factor integrante\n\nAhora, multiplicamos cada t√©rmino de la ecuaci√≥n original por $\\mu(x) = e^{2x}$:\n$$ e^{2x} \\left( \\frac{dy}{dx} + 2y \\right) = e^{2x} (e^{-x}) $$\n$$ e^{2x}\\frac{dy}{dx} + 2e^{2x}y = e^{2x-x} $$\n$$ e^{2x}\\frac{dy}{dx} + 2e^{2x}y = e^{x} $$\n\n---\n\n### Paso 4: Reconocer la regla del producto en el lado izquierdo\n\nLa clave del m√©todo del factor integrante es que el lado izquierdo de la ecuaci√≥n se convierte en la derivada del producto del factor integrante y la funci√≥n $y$:\n$$ \\frac{d}{dx} \\left( \\mu(x) \\cdot y \\right) = e^{2x}\\frac{dy}{dx} + 2e^{2x}y $$\nAs√≠ que podemos reescribir nuestra ecuaci√≥n como:\n$$ \\frac{d}{dx} (e^{2x}y) = e^{x} $$\n\n---\n\n### Paso 5: Integrar ambos lados de la ecuaci√≥n\n\nAhora integramos ambos lados con respecto a $x$:\n$$ \\int \\frac{d}{dx} (e^{2x}y) dx = \\int e^{x} dx $$\nLa integral de la derivada se cancela, dej√°ndonos con:\n$$ e^{2x}y = e^{x} + C $$\nDonde $C$ es la constante de integraci√≥n.\n\n---\n\n### Paso 6: Despejar y para encontrar la soluci√≥n general\n\nPara obtener la soluci√≥n general, despejamos $y$ dividiendo toda la ecuaci√≥n por $e^{2x}$:\n$$ y = \\frac{e^{x} + C}{e^{2x}} $$\n$$ y = \\frac{e^{x}}{e^{2x}} + \\frac{C}{e^{2x}} $$\n$$ y(x) = e^{-x} + Ce^{-2x} $$\nEsta es la **soluci√≥n general** de la ecuaci√≥n diferencial.\n\n---\n\n### Paso 7: Aplicar la condici√≥n inicial para encontrar C\n\nAhora usamos la condici√≥n inicial $y(0) = 1$ para encontrar el valor de la constante $C$. Esto significa que cuando $x=0$, $y=1$.\nSustituimos estos valores en la soluci√≥n general:\n$$ 1 = e^{-(0)} + Ce^{-2(0)} $$\n$$ 1 = e^{0} + Ce^{0} $$\n$$ 1 = 1 + C(1) $$\n$$ 1 = 1 + C $$\nResolviendo para $C$:\n$$ C = 1 - 1 = 0 $$\n\n---\n\n### Paso 8: Escribir la soluci√≥n particular\n\nFinalmente, sustituimos el valor de $C=0$ en la soluci√≥n general para obtener la soluci√≥n particular (o √∫nica) que satisface la condici√≥n inicial.\n$$ y(x) = e^{-x} + (0)e^{-2x} $$\n$$ y(x) = e^{-x} $$\n\n---\n\n### Soluci√≥n Final\n\nLa soluci√≥n a la ecuaci√≥n diferencial $\\frac{dy}{dx} + 2y = e^{-x}$ con la condici√≥n inicial $y(0) = 1$ es:\n$$ \\Large y(x) = e^{-x} $$",
      "score": 0.6,
      "response_time": 22.623558044433594,
      "cost": 0.028255000000000002,
      "tokens_used": 2850,
      "success": true,
      "error": null
    },
    {
      "model": "GPT-5",
      "domain": "programming",
      "query": "Implementa un algoritmo de ordenamiento quicksort optimizado en Python con an√°lisis de complejidad",
      "response": "A continuaci√≥n tienes una implementaci√≥n de quicksort optimizado en Python, in-place, iterativo (sin recursi√≥n profunda), con selecci√≥n de pivote por mediana-de-tres, partici√≥n 3-v√≠as para manejar eficientemente duplicados y cambio a insertion sort en subarreglos peque√±os:\n\n```python\nfrom typing import MutableSequence, Any\n\ndef quicksort(a: MutableSequence[Any], threshold: int = 16) -> MutableSequence[Any]:\n    \"\"\"\n    Quicksort optimizado in-place.\n    Optimizaciones:\n      - Mediana-de-tres para escoger el pivote.\n      - Partici√≥n 3-v√≠as (<, =, >) para manejar duplicados eficientemente.\n      - Cambio a insertion sort en subarreglos peque√±os (threshold).\n      - Iterativo con pila y \"tail-call elimination\" para limitar el tama√±o de la pila a O(log n).\n\n    Par√°metros:\n      a: Secuencia mutable indexable (lista, etc.) con elementos comparables.\n      threshold: Tama√±o m√°ximo para usar insertion sort en subarreglos peque√±os.\n\n    Retorna:\n      La misma secuencia, ordenada in-place (tambi√©n se modifica el argumento).\n    \"\"\"\n    n = len(a)\n    if n < 2:\n        return a\n\n    def insertion_sort(lo: int, hi: int) -> None:\n        for i in range(lo + 1, hi + 1):\n            x = a[i]\n            j = i - 1\n            while j >= lo and a[j] > x:\n                a[j + 1] = a[j]\n                j -= 1\n            a[j + 1] = x\n\n    def median_of_three(lo: int, hi: int) -> None:\n        \"\"\"\n        Coloca la mediana de (a[lo], a[mid], a[hi]) en a[lo].\n        \"\"\"\n        mid = (lo + hi) // 2\n        # Ordena a[lo], a[mid], a[hi] parcialmente para que a[mid] sea la mediana\n        if a[mid] < a[lo]:\n            a[lo], a[mid] = a[mid], a[lo]\n        if a[hi] < a[lo]:\n            a[lo], a[hi] = a[hi], a[lo]\n        if a[hi] < a[mid]:\n            a[mid], a[hi] = a[hi], a[mid]\n        # Mueve la mediana a la posici√≥n lo como pivote\n        a[lo], a[mid] = a[mid], a[lo]\n\n    # Pila de segmentos [lo, hi] a ordenar\n    stack = [(0, n - 1)]\n\n    while stack:\n        lo, hi = stack.pop()\n        while lo < hi:\n            # Subarreglo peque√±o: insertion sort\n            if hi - lo + 1 <= threshold:\n                insertion_sort(lo, hi)\n                break\n\n            # Selecci√≥n de pivote por mediana-de-tres\n            median_of_three(lo, hi)\n            pivot = a[lo]\n\n            # Partici√≥n 3-v√≠as de Dijkstra: < pivot | = pivot | > pivot\n            lt, i, gt = lo, lo + 1, hi\n            while i <= gt:\n                if a[i] < pivot:\n                    a[lt], a[i] = a[i], a[lt]\n                    lt += 1\n                    i += 1\n                elif a[i] > pivot:\n                    a[i], a[gt] = a[gt], a[i]\n                    gt -= 1\n                else:\n                    i += 1\n\n            # Ahora hay dos segmentos por ordenar: [lo, lt-1] y [gt+1, hi]\n            left_lo, left_hi = lo, lt - 1\n            right_lo, right_hi = gt + 1, hi\n\n            # Tail-call elimination: procesa primero el segmento m√°s peque√±o,\n            # empuja el grande a la pila para mantener profundidad O(log n)\n            left_len = left_hi - left_lo + 1\n            right_len = right_hi - right_lo + 1\n\n            if left_len < right_len:\n                if right_len > 0:\n                    stack.append((right_lo, right_hi))\n                # Continuar iterando sobre el segmento peque√±o\n                hi = left_hi\n                # lo permanece igual\n            else:\n                if left_len > 0:\n                    stack.append((left_lo, left_hi))\n                lo = right_lo\n                # hi permanece igual\n\n    return a\n\n# Ejemplo de uso:\nif __name__ == \"__main__\":\n    data = [5, 3, 8, 3, 9, 1, 0, 7, 3, 2, 6, 4]\n    quicksort(data)\n    print(data)  # Ordenado\n```\n\nAn√°lisis de complejidad:\n- Tiempo promedio: O(n log n). La selecci√≥n por mediana-de-tres reduce la probabilidad de particiones muy desbalanceadas. La partici√≥n 3-v√≠as evita trabajo extra cuando hay muchos duplicados (en esos casos, se aproxima a O(n)).\n- Peor caso: O(n^2). A√∫n con mediana-de-tres puede construirse una entrada adversarial; una alternativa es pivote aleatorio para asegurar O(n log n) esperado. La conmutaci√≥n a insertion sort no cambia el orden asint√≥tico, pero mejora la constante.\n- Mejor caso: O(n log n) con particiones balanceadas; con muchos elementos iguales, el trabajo se reduce y puede acercarse a O(n).\n- Espacio auxiliar: O(log n) por el uso controlado de una pila expl√≠cita (siempre se procesa primero el segmento m√°s peque√±o). El algoritmo es in-place (no asigna arreglos adicionales).\n- Estabilidad: No estable (el orden relativo de iguales no est√° garantizado). Si se requiere estabilidad, usar mergesort o timsort (el sort nativo de Python) con key apropiado.",
      "score": 0.9999999999999999,
      "response_time": 36.67202877998352,
      "cost": 3.319125e-05,
      "tokens_used": 3341,
      "success": true,
      "error": null
    },
    {
      "model": "GPT-5",
      "domain": "programming",
      "query": "Crea una funci√≥n que detecte si un grafo es bipartito usando BFS",
      "response": "Aqu√≠ tienes una implementaci√≥n con BFS para comprobar si un grafo no dirigido es bipartito. Usa coloreado 0/1: si encontramos una arista entre dos v√©rtices del mismo color, no es bipartito.\n\nPython (lista de adyacencia)\ndef es_bipartito(grafo):\n    # grafo: lista de listas, grafo[u] contiene los vecinos de u\n    from collections import deque\n    n = len(grafo)\n    color = [-1] * n  # -1: sin color, 0/1: colores de las dos particiones\n\n    for s in range(n):  # manejar componentes desconectados\n        if color[s] != -1:\n            continue\n        color[s] = 0\n        q = deque([s])\n\n        while q:\n            u = q.popleft()\n            for v in grafo[u]:\n                if color[v] == -1:\n                    color[v] = 1 - color[u]\n                    q.append(v)\n                elif color[v] == color[u]:\n                    return False\n    return True\n\n# Ejemplo:\n# grafo bipartito: 0-1, 0-3, 2-1, 2-3\ng1 = [[1,3], [0,2], [1,3], [0,2]]\nprint(es_bipartito(g1))  # True\n\n# grafo no bipartito (tri√°ngulo): 0-1-2-0\ng2 = [[1,2], [0,2], [0,1]]\nprint(es_bipartito(g2))  # False\n\nNotas:\n- Complejidad: O(V + E)\n- Detecta la no bipartici√≥n tambi√©n en presencia de bucles (self-loops) o aristas m√∫ltiples.\n- Supone grafo no dirigido (si es dirigido, la noci√≥n de bipartito cambia).",
      "score": 0.7000000000000001,
      "response_time": 13.41412091255188,
      "cost": 9.238750000000002e-06,
      "tokens_used": 944,
      "success": true,
      "error": null
    },
    {
      "model": "GPT-5",
      "domain": "programming",
      "query": "Desarrolla un sistema de cach√© LRU con complejidad O(1) para todas las operaciones",
      "response": "A continuaci√≥n tienes una implementaci√≥n completa de una cach√© LRU con operaciones O(1) usando un diccionario (hash map) y una lista doblemente enlazada. Incluye m√©todos get, put, delete, contains y len.\n\nC√≥digo (Python 3):\n\n```python\nfrom typing import Any, Optional\n\nclass _Node:\n    __slots__ = (\"key\", \"value\", \"prev\", \"next\")\n    def __init__(self, key: Any, value: Any):\n        self.key = key\n        self.value = value\n        self.prev: Optional[\"_Node\"] = None\n        self.next: Optional[\"_Node\"] = None\n\nclass LRUCache:\n    \"\"\"\n    Cach√© LRU con operaciones O(1):\n      - get(key) -> obtiene el valor y marca como recientemente usado\n      - put(key, value) -> inserta/actualiza y, si es necesario, expulsa el menos usado\n      - delete(key) -> elimina una clave en O(1)\n      - __contains__(key) -> membership en O(1)\n      - __len__() -> n√∫mero de elementos\n    \"\"\"\n    def __init__(self, capacity: int):\n        if capacity < 0:\n            raise ValueError(\"capacity debe ser >= 0\")\n        self.capacity = capacity\n        self.map: dict[Any, _Node] = {}\n\n        # Centinelas de la lista doblemente enlazada: head <-> ... <-> tail\n        self.head = _Node(None, None)  # MRU se inserta despu√©s de head\n        self.tail = _Node(None, None)  # LRU est√° antes de tail\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    # --- Utilidades de lista doblemente enlazada (todas O(1)) ---\n\n    def _add_after_head(self, node: _Node) -> None:\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n\n    def _remove_node(self, node: _Node) -> None:\n        prev, nxt = node.prev, node.next\n        # prev y nxt no son None por construcci√≥n (centinelas)\n        prev.next = nxt\n        nxt.prev = prev\n        node.prev = node.next = None  # opcional, para ayudar al GC\n\n    def _move_to_head(self, node: _Node) -> None:\n        self._remove_node(node)\n        self._add_after_head(node)\n\n    def _pop_lru(self) -> _Node:\n        # El LRU es el nodo antes de tail\n        lru = self.tail.prev\n        if lru is self.head:\n            return None  # no hay elementos\n        self._remove_node(lru)\n        return lru\n\n    # --- API p√∫blica ---\n\n    def get(self, key: Any, default: Any = None) -> Any:\n        \"\"\"\n        Devuelve el valor asociado a key y lo marca como recientemente usado.\n        Si no existe, devuelve default (None por defecto).\n        \"\"\"\n        node = self.map.get(key)\n        if not node:\n            return default\n        self._move_to_head(node)\n        return node.value\n\n    def put(self, key: Any, value: Any) -> None:\n        \"\"\"\n        Inserta o actualiza key con value. Si se supera la capacidad,\n        expulsa el elemento menos recientemente usado.\n        \"\"\"\n        if self.capacity == 0:\n            # Capacidad cero: comportamiento definido (no almacena nada)\n            return\n\n        node = self.map.get(key)\n        if node:\n            node.value = value\n            self._move_to_head(node)\n            return\n\n        new_node = _Node(key, value)\n        self.map[key] = new_node\n        self._add_after_head(new_node)\n\n        if len(self.map) > self.capacity:\n            lru = self._pop_lru()\n            if lru is not None and lru.key in self.map:\n                del self.map[lru.key]\n\n    def delete(self, key: Any) -> bool:\n        \"\"\"\n        Elimina key si existe. Devuelve True si se elimin√≥, False si no estaba.\n        \"\"\"\n        node = self.map.pop(key, None)\n        if not node:\n            return False\n        self._remove_node(node)\n        return True\n\n    def __contains__(self, key: Any) -> bool:\n        return key in self.map\n\n    def __len__(self) -> int:\n        return len(self.map)\n\n    def keys_mru_to_lru(self):\n        \"\"\"\n        Iterador de claves desde la m√°s reciente (MRU) a la menos reciente (LRU).\n        √ötil para depuraci√≥n; O(n).\n        \"\"\"\n        cur = self.head.next\n        while cur is not None and cur is not self.tail:\n            yield cur.key\n            cur = cur.next\n\n# Ejemplo de uso\nif __name__ == \"__main__\":\n    cache = LRUCache(capacity=2)\n    cache.put(\"a\", 1)          # cache: a\n    cache.put(\"b\", 2)          # cache: b, a  (b es MRU)\n    print(cache.get(\"a\"))      # 1; cache: a, b\n    cache.put(\"c\", 3)          # expulsa b; cache: c, a\n    print(cache.get(\"b\"))      # None (no est√°)\n    cache.put(\"a\", 10)         # actualiza a; cache: a, c\n    print(list(cache.keys_mru_to_lru()))  # ['a', 'c']\n```\n\nNotas:\n- Estructuras: diccionario para acceso O(1) por clave y lista doblemente enlazada para mover elementos a MRU/expulsar LRU en O(1).\n- Complejidad: get/put/delete son O(1) en tiempo; uso de memoria O(capacidad).\n- Si prefieres otra interfaz (por ejemplo, get que lance excepci√≥n o devuelva -1 cuando no existe), d√≠melo y la ajusto. Tambi√©n puedo proveer implementaciones equivalentes en Java, C++ o Go.",
      "score": 1.0,
      "response_time": 29.725056171417236,
      "cost": 2.3275e-05,
      "tokens_used": 2352,
      "success": true,
      "error": null
    },
    {
      "model": "GPT-5",
      "domain": "reasoning",
      "query": "Analiza la complejidad computacional del problema del viajante y prop√≥n una soluci√≥n aproximada",
      "response": "Resumen\n- El problema del viajante (TSP) es NP-duro en su versi√≥n de optimizaci√≥n y su versi√≥n de decisi√≥n es NP-completa. Los algoritmos exactos escalan exponencialmente.\n- Con tri√°ngulo desigualdad (TSP m√©trico, sim√©trico) existen algoritmos de aproximaci√≥n con garant√≠as: el de Christofides alcanza factor 1.5. En el TSP euclidiano existe un PTAS. Para TSP asim√©trico (ATSP) existen algoritmos de aproximaci√≥n con factor constante, aunque son complejos; enfoques sencillos dan factores O(log n).\n- En la pr√°ctica, heur√≠sticas como 2-opt/3-opt o Lin‚ÄìKernighan (LKH) obtienen soluciones de alta calidad en grandes instancias.\n\nComplejidad computacional\n- Definici√≥n: Dado un grafo completo con pesos no negativos, se busca un ciclo hamiltoniano de coste m√≠nimo.\n- Complejidad exacta:\n  - Decisi√≥n ‚Äú¬øexiste tour de coste ‚â§ K?‚Äù: NP-completa.\n  - Optimizaci√≥n: NP-dura.\n  - Algoritmos exactos:\n    - Programaci√≥n din√°mica de Held‚ÄìKarp: tiempo Œò(n^2¬∑2^n), espacio Œò(n¬∑2^n).\n    - M√©todos de ILP con planos de corte (p. ej., Concorde): resuelven instancias muy grandes, pero el peor caso sigue siendo exponencial.\n- Aproximaci√≥n y dureza:\n  - TSP general (sin tri√°ngulo desigualdad): no admite aproximaci√≥n con ning√∫n factor constante en tiempo polin√≥mico a menos que P=NP.\n  - TSP m√©trico sim√©trico (distancias cumplen tri√°ngulo desigualdad): algoritmo de Christofides con garant√≠a 3/2; el problema es APX-duro (no hay PTAS salvo que P=NP).\n  - TSP euclidiano (puntos en R^d con distancia euclidiana): existe PTAS (Arora, Mitchell).\n  - ATSP (m√©trico dirigido): se conocen algoritmos con factor constante (te√≥ricamente), pero pr√°cticos y sencillos dan O(log n).\n\nSoluci√≥n aproximada propuesta (m√©trico, sim√©trico): algoritmo de Christofides + mejora local\nRequisitos: distancias sim√©tricas y con tri√°ngulo desigualdad.\n\nPasos:\n1) √Årbol de expansi√≥n m√≠nima (MST).\n2) Conjunto de v√©rtices de grado impar en el MST.\n3) Emparejamiento perfecto m√≠nimo sobre esos v√©rtices (en el grafo completo inducido por ellos).\n4) Unir MST + emparejamiento ‚áí multigrafo euleriano.\n5) Recorrer un tour euleriano (cada arista una vez).\n6) Atajar (shortcutting) saltando v√©rtices ya visitados para obtener un ciclo hamiltoniano.\n\nPropiedades:\n- Garant√≠a de aproximaci√≥n: ‚â§ 1.5 veces el √≥ptimo.\n- Complejidad temporal: dominada por el emparejamiento perfecto m√≠nimo (Blossom) O(n^3); el MST es O(m log n) (en completo, m‚âàn^2), eulerizaci√≥n y atajos lineales en m.\n\nMejora pr√°ctica: b√∫squeda local\n- Aplicar 2-opt y 3-opt sobre el tour de Christofides:\n  - 2-opt: intercambiar dos aristas si reduce la longitud. Iterar hasta punto fijo.\n  - 3-opt/Lin‚ÄìKernighan (LK/LKH): intercambios m√°s generales; t√≠picamente muy cercanos al √≥ptimo en datos euclidianos.\n- Complejidad: cada pasada 2-opt O(n^2) en implementaci√≥n eficiente; en la pr√°ctica se detiene en tiempos razonables con resultados de alta calidad.\n\nCaso asim√©trico (ATSP) o sin tri√°ngulo desigualdad\n- Enfoque simple con garant√≠a (m√©trico dirigido):\n  - Hallar una cobertura por ciclos de coste m√≠nimo (problema de asignaci√≥n; m√©todo H√∫ngaro O(n^3)).\n  - ‚ÄúPegar‚Äù los ciclos en un solo tour mediante arcos adicionales y atajos. Garant√≠a O(log n); existen algoritmos con factor constante pero mucho m√°s complejos.\n- Sin tri√°ngulo desigualdad: no hay garant√≠as conocidas. Usar heur√≠sticas (inserci√≥n m√°s cercana/lejana, GRASP, recocido simulado, gen√©ticos, ACO) y mejoras locales.\n\nNotas pr√°cticas\n- Si las distancias son euclidianas: usar LKH o un PTAS si se requieren garant√≠as formales y n no es enorme.\n- Para instancias grandes sin requisitos de prueba de optimalidad: LKH (o LKH-3) suele ser la mejor opci√≥n; combinar con m√∫ltiples reinicios y semillas aleatorias.\n- Preprocesado: verificar tri√°ngulo desigualdad; si no se cumple, considerar ‚Äúmetric closure‚Äù (distancias de caminos m√°s cortos) si el problema lo permite.\n\nSi quieres, puedo darte pseudoc√≥digo de Christofides, un boceto de 2-opt, o adaptar la estrategia a tu tipo de datos (euclidiano, dirigido, etc.).",
      "score": 0.6,
      "response_time": 32.74140477180481,
      "cost": 3.02025e-05,
      "tokens_used": 3043,
      "success": true,
      "error": null
    },
    {
      "model": "GPT-5",
      "domain": "reasoning",
      "query": "Explica paso a paso c√≥mo resolver el problema de las 8 reinas usando backtracking",
      "response": "Aqu√≠ tienes una gu√≠a paso a paso para resolver el problema de las 8 reinas con backtracking (vuelta atr√°s), m√°s un ejemplo en c√≥digo para que puedas implementarlo.\n\nIdea del problema\n- Colocar 8 reinas en un tablero 8√ó8 sin que se ataquen.\n- Dos reinas se atacan si comparten fila, columna o diagonal.\n\nEstrategia de backtracking (vuelta atr√°s)\n1) Colocar por filas\n- Recorremos el tablero fila por fila (de 0 a 7).\n- En cada fila intentamos colocar una reina en alguna columna v√°lida.\n\n2) Representaci√≥n conveniente\n- Usa un arreglo colPorFila de tama√±o 8, donde colPorFila[f] = c indica que en la fila f la reina est√° en la columna c.\n- Mant√©n estructuras para chequear r√°pido si una columna o diagonal est√° ocupada:\n  - columnas[c] = True si la columna c ya tiene una reina.\n  - diag1[i] = True para la diagonal ‚Äúprincipal‚Äù de √≠ndice i = (fila - col) + (n - 1).\n  - diag2[j] = True para la diagonal ‚Äúsecundaria‚Äù de √≠ndice j = (fila + col).\n  (Para n=8, diag1 y diag2 tienen tama√±o 15.)\n\n3) Funci√≥n recursiva colocar(fila)\n- Caso base: si fila == 8, hemos colocado 8 reinas sin conflicto; registrar la soluci√≥n.\n- Paso recursivo: para cada col en 0..7:\n  - Si columnas[col], diag1[fila-col + 7] y diag2[fila+col] est√°n libres:\n    - Marca esas estructuras como ocupadas.\n    - Guarda col en colPorFila[fila].\n    - Llama recursivamente a colocar(fila + 1).\n    - Si la llamada termina, desmarca (backtrack) para probar otra columna.\n\n4) ¬øPor qu√© funciona?\n- En cada nivel exploras solo las posiciones compatibles con lo ya colocado.\n- Si te quedas sin columnas v√°lidas en una fila, retrocedes a la fila anterior y pruebas la siguiente opci√≥n.\n- Cuando llegas a fila 8, tienes una configuraci√≥n completa v√°lida.\n\n5) Complejidad\n- En el peor caso es exponencial (~O(n!)), pero el podado por columnas y diagonales reduce mucho el espacio de b√∫squeda.\n- Para 8 reinas hay 92 soluciones distintas.\n\nEjemplo en Python (backtracking cl√°sico)\n- Devuelve todas las soluciones como listas de columnas por fila.\n- Incluye una funci√≥n para imprimir el tablero.\n\ndef resolver_8_reinas():\n    n = 8\n    colPorFila = [-1] * n\n    columnas = [False] * n\n    diag1 = [False] * (2 * n - 1)  # √≠ndices: fila - col + (n-1)\n    diag2 = [False] * (2 * n - 1)  # √≠ndices: fila + col\n    soluciones = []\n\n    def backtrack(fila):\n        if fila == n:\n            soluciones.append(colPorFila.copy())\n            return\n        for col in range(n):\n            d1 = fila - col + (n - 1)\n            d2 = fila + col\n            if not columnas[col] and not diag1[d1] and not diag2[d2]:\n                # Colocar\n                colPorFila[fila] = col\n                columnas[col] = True\n                diag1[d1] = True\n                diag2[d2] = True\n\n                backtrack(fila + 1)\n\n                # Retroceder\n                columnas[col] = False\n                diag1[d1] = False\n                diag2[d2] = False\n                colPorFila[fila] = -1\n\n    backtrack(0)\n    return soluciones\n\ndef imprimir_tablero(solucion):\n    n = len(solucion)\n    for fila in range(n):\n        linea = []\n        for col in range(n):\n            linea.append('Q' if solucion[fila] == col else '.')\n        print(' '.join(linea))\n    print()\n\n# Uso:\nsoluciones = resolver_8_reinas()\nprint(f\"Total de soluciones: {len(soluciones)}\")\n# Imprime la primera soluci√≥n como ejemplo\nimprimir_tablero(soluciones[0])\n\nC√≥mo leer la salida\n- Cada soluci√≥n es una lista de 8 n√∫meros: la columna donde va la reina en cada fila.\n- La funci√≥n imprimir_tablero muestra un tablero con Q para la reina y . para casillas vac√≠as.\n\nConsejos y variantes\n- Para obtener solo una soluci√≥n: det√©n la b√∫squeda cuando encuentres la primera (por ejemplo, lanzando una excepci√≥n controlada o usando una variable de estado para cortar).\n- Optimizaci√≥n con bitmasks (m√°s r√°pido):\n  - Representa columnas, diag1 y diag2 como enteros de bits.\n  - En cada fila, calcula posiciones disponibles con: libres = ~(cols | d1 | d2) & ((1 << n) - 1).\n  - Itera con el truco del bit menos significativo: p = libres & -libres; libres -= p; y avanza con d1, d2 desplazados.\n- Simetr√≠as: puedes fijar la reina de la primera fila en la mitad de columnas y reflejar, para reducir trabajo cuando solo quieres contar soluciones.\n\nResumen del flujo\n- Intentar columna por columna en la fila actual.\n- Si la posici√≥n es segura (columna y diagonales libres), colocar y avanzar a la siguiente fila.\n- Si no hay opciones, retroceder a la fila anterior y probar otra columna.\n- Repetir hasta completar 8 filas; registrar cada soluci√≥n encontrada.\n\nCon esto tienes el m√©todo de backtracking claro y un ejemplo listo para ejecutar.",
      "score": 0.75,
      "response_time": 30.061227083206177,
      "cost": 2.3050000000000005e-05,
      "tokens_used": 2326,
      "success": true,
      "error": null
    },
    {
      "model": "GPT-5",
      "domain": "reasoning",
      "query": "Demuestra por qu√© el algoritmo de Dijkstra no funciona con pesos negativos",
      "response": "Idea clave\nDijkstra es un algoritmo codicioso: cuando extrae el v√©rtice u con la menor distancia provisional d[u], lo ‚Äúfija‚Äù asumiendo que esa distancia ya es √≥ptima y nunca podr√° mejorar. Eso solo es cierto si todas las aristas tienen peso no negativo. Con pesos negativos, puede aparecer m√°s tarde un camino que abarate d[u], pero Dijkstra ya no reabre u y se equivoca.\n\nContraejemplo m√≠nimo (sin ciclos negativos)\n- V√©rtices: s, a, b\n- Aristas dirigidas y pesos:\n  - s ‚Üí a con peso 2\n  - s ‚Üí b con peso 5\n  - b ‚Üí a con peso ‚àí4\n\nDistancias reales desde s:\n- El mejor camino a a es s ‚Üí b ‚Üí a con costo 5 + (‚àí4) = 1.\n- Tambi√©n existe s ‚Üí a con costo 2, pero no es √≥ptimo.\n\nEjecuci√≥n de Dijkstra:\n1) Inicializa: d[s]=0, d[a]=2, d[b]=5.\n2) Extrae y fija a (es el menor: 2). Dijkstra asume que d[a]=2 es definitivo.\n3) Extrae b (5) y relaja b ‚Üí a: propondr√≠a d[a]=5+(‚àí4)=1, pero a ya est√° fijado, as√≠ que Dijkstra lo ignora.\nResultado: Dijkstra devuelve d[a]=2, que es incorrecto (la distancia √≥ptima es 1).\n\nD√≥nde se rompe la prueba\nEl paso cr√≠tico de la correcci√≥n de Dijkstra usa que los pesos son ‚â• 0:\n- Al fijar u como el menor d[u], para cualquier otro v√©rtice x a√∫n no fijado se cumple d[x] ‚â• d[u].\n- Con pesos no negativos, cualquier camino que vaya primero a x y luego a u tiene costo al menos d[x] + w(x,u) ‚â• d[u], as√≠ que no puede mejorar d[u].\n- Si w(x,u) puede ser negativo, este razonamiento falla: es posible que d[x] > d[u] pero d[x] + w(x,u) < d[u] (exactamente 5 + (‚àí4) = 1 < 2 en el ejemplo).\n\nConclusi√≥n\n- Dijkstra solo es correcto con pesos no negativos.\n- Con pesos negativos (y sin ciclos negativos), usa Bellman-Ford; para muchos or√≠genes en grafos dispersos, Johnson es otra opci√≥n.",
      "score": 0.5,
      "response_time": 53.2357394695282,
      "cost": 2.8295000000000003e-05,
      "tokens_used": 2847,
      "success": true,
      "error": null
    },
    {
      "model": "GPT-5",
      "domain": "mathematics",
      "query": "Demuestra la f√≥rmula de Euler e^(iœÄ) + 1 = 0 usando series de Taylor",
      "response": "Demostraci√≥n con series de Taylor:\n\n1) Series de Taylor (v√°lidas para todo n√∫mero real o complejo x, con convergencia absoluta):\n- e^z = 1 + z + z^2/2! + z^3/3! + ...\n- cos x = 1 ‚àí x^2/2! + x^4/4! ‚àí x^6/6! + ...\n- sin x = x ‚àí x^3/3! + x^5/5! ‚àí x^7/7! + ...\n\n2) Sustituye z = i x en la serie de e^z:\ne^(i x) = 1 + i x + (i x)^2/2! + (i x)^3/3! + (i x)^4/4! + ...\n= 1 + i x ‚àí x^2/2! ‚àí i x^3/3! + x^4/4! + i x^5/5! ‚àí ...\n\nSepara en parte real e imaginaria:\n- Parte real: 1 ‚àí x^2/2! + x^4/4! ‚àí x^6/6! + ... = cos x\n- Parte imaginaria: i [x ‚àí x^3/3! + x^5/5! ‚àí x^7/7! + ...] = i sin x\n\nPor tanto, e^(i x) = cos x + i sin x.\n\n3) Eval√∫a en x = œÄ:\ne^(i œÄ) = cos œÄ + i sin œÄ = (‚àí1) + i¬∑0 = ‚àí1\n\nLuego, e^(i œÄ) + 1 = 0.",
      "score": 0.45000000000000007,
      "response_time": 25.92599368095398,
      "cost": 1.383375e-05,
      "tokens_used": 1407,
      "success": true,
      "error": null
    },
    {
      "model": "GPT-5",
      "domain": "mathematics",
      "query": "Calcula la derivada de la funci√≥n f(x) = ln(sin(x^2)) usando la regla de la cadena",
      "response": "f(x) = ln(sin(x^2))\n\nAplicando la regla de la cadena en dos capas:\n- Derivada de ln(u) es 1/u ¬∑ u'\n- u = sin(x^2), cuya derivada es cos(x^2) ¬∑ 2x\n\nEntonces:\nf'(x) = (1/sin(x^2)) ¬∑ (cos(x^2) ¬∑ 2x) = 2x ¬∑ cot(x^2)\n\nDominio para la derivada: sin(x^2) ‚â† 0 (y para f, sin(x^2) > 0).",
      "score": 0.2,
      "response_time": 9.134127616882324,
      "cost": 5.198750000000001e-06,
      "tokens_used": 547,
      "success": true,
      "error": null
    },
    {
      "model": "GPT-5",
      "domain": "mathematics",
      "query": "Resuelve la ecuaci√≥n diferencial dy/dx + 2y = e^(-x) con condici√≥n inicial y(0) = 1",
      "response": "Ecuaci√≥n: y' + 2y = e^{-x}, y(0) = 1.\n\n- Factor integrante: Œº(x) = e^{‚à´2 dx} = e^{2x}.\n- Entonces (e^{2x} y)' = e^{2x} e^{-x} = e^{x}.\n- Integramos: e^{2x} y = e^{x} + C.\n- Despejamos: y = e^{-x} + C e^{-2x}.\n- Condici√≥n inicial: 1 = y(0) = 1 + C ‚áí C = 0.\n\nSoluci√≥n: y(x) = e^{-x}.",
      "score": 0.2,
      "response_time": 11.643286228179932,
      "cost": 5.993750000000001e-06,
      "tokens_used": 630,
      "success": true,
      "error": null
    }
  ]
}